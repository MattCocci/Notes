\documentclass[12pt]{article}

\author{Matthew D. Cocci}
\title{Title}
\date{\today}

%% Formatting & Spacing %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\usepackage[top=1in, bottom=1in, left=1in, right=1in]{geometry} % most detailed page formatting control
\usepackage{fullpage} % Simpler than using the geometry package; std effect
\usepackage{setspace}
%\onehalfspacing
\usepackage{microtype}

%% Formatting %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\usepackage[margin=1in]{geometry}
    %   Adjust the margins with geometry package
%\usepackage{pdflscape}
    %   Allows landscape pages
%\usepackage{layout}
    %   Allows plotting of picture of formatting
\usepackage{version}
\excludeversion{solutions}
%\includeversion{solutions}



%% Header %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\usepackage{fancyhdr}
%\pagestyle{fancy}
%\lhead{}
%\rhead{}
%\chead{}
%\setlength{\headheight}{15.2pt}
    %   Make the header bigger to avoid overlap

%\fancyhf{}
    %   Erase header settings

%\renewcommand{\headrulewidth}{0.3pt}
    %   Width of the line

%\setlength{\headsep}{0.2in}
    %   Distance from line to text


%% Mathematics Related %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{mathrsfs}
\usepackage{mathtools}
\usepackage{amsthm} %allows for labeling of theorems
%\numberwithin{equation}{section} % Number equations by section
\usepackage{bbm} % For bold numbers

\theoremstyle{plain}
\newtheorem{thm}{Theorem}[section]
\newtheorem{lem}[thm]{Lemma}
\newtheorem{prop}[thm]{Proposition}
\newtheorem{cor}[thm]{Corollary}

\theoremstyle{definition}
\newtheorem{defn}[thm]{Definition}
\newtheorem{ex}[thm]{Example}

\theoremstyle{remark}
\newtheorem*{rmk}{Remark}
\newtheorem*{note}{Note}

% Below supports left-right alignment in matrices so the negative
% signs don't look bad
\makeatletter
\renewcommand*\env@matrix[1][c]{\hskip -\arraycolsep
  \let\@ifnextchar\new@ifnextchar
  \array{*\c@MaxMatrixCols #1}}
\makeatother


%% Font Choices %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[utf8]{inputenc}
%\usepackage{blindtext}
\usepackage{courier}


%% Figures %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{tikz}
\usetikzlibrary{decorations.pathreplacing}
\usetikzlibrary{arrows.meta}
\usepackage{graphicx}
\usepackage{subfigure}
    %   For plotting multiple figures at once
%\graphicspath{ {Directory/} }
    %   Set a directory for where to look for figures


%% Hyperlinks %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{hyperref}
\hypersetup{%
    colorlinks,
        %   This colors the links themselves, not boxes
    citecolor=black,
        %   Everything here and below changes link colors
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}

%% Colors %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{color}
\definecolor{codegreen}{RGB}{28,172,0}
\definecolor{codelilas}{RGB}{170,55,241}

% David4 color scheme
\definecolor{d4blue}{RGB}{100,191,255}
\definecolor{d4gray}{RGB}{175,175,175}
\definecolor{d4black}{RGB}{85,85,85}
\definecolor{d4orange}{RGB}{255,150,100}

%% Including Code %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{verbatim}
    %   For including verbatim code from files, no colors
\usepackage{listings}
    %   For including code snippets written directly in this doc

\lstdefinestyle{bash}{%
  language=bash,%
  basicstyle=\footnotesize\ttfamily,%
  showstringspaces=false,%
  commentstyle=\color{gray},%
  keywordstyle=\color{blue},%
  xleftmargin=0.25in,%
  xrightmargin=0.25in
}
\lstdefinestyle{log}{%
  basicstyle=\scriptsize\ttfamily,%
  showstringspaces=false,%
  xleftmargin=0.25in,%
  xrightmargin=0.25in
}


\lstdefinestyle{matlab}{%
  language=Matlab,%
  basicstyle=\footnotesize\ttfamily,%
  breaklines=true,%
  morekeywords={matlab2tikz},%
  keywordstyle=\color{blue},%
  morekeywords=[2]{1}, keywordstyle=[2]{\color{black}},%
  identifierstyle=\color{black},%
  stringstyle=\color{codelilas},%
  commentstyle=\color{codegreen},%
  showstringspaces=false,%
    %   Without this there will be a symbol in
    %   the places where there is a space
  %numbers=left,%
  %numberstyle={\tiny \color{black}},%
    %   Size of the numbers
  numbersep=9pt,%
    %   Defines how far the numbers are from the text
  emph=[1]{for,end,break,switch,case},emphstyle=[1]\color{blue},%
    %   Some words to emphasise
}

\newcommand{\matlabcode}[1]{%
    \lstset{style=matlab}%
    \lstinputlisting{#1}
}
    %   For including Matlab code from .m file with colors,
    %   line numbering, etc.

\lstdefinelanguage{Julia}%
  {morekeywords={abstract,break,case,catch,const,continue,do,else,elseif,%
      end,export,false,for,function,immutable,import,importall,if,in,%
      macro,module,otherwise,quote,return,switch,true,try,type,typealias,%
      using,while},%
   sensitive=true,%
   %alsoother={$},%
   morecomment=[l]\#,%
   morecomment=[n]{\#=}{=\#},%
   morestring=[s]{"}{"},%
   morestring=[m]{'}{'},%
}[keywords,comments,strings]

\lstdefinestyle{julia}{%
    language         = Julia,
    basicstyle       = \scriptsize\ttfamily,
    keywordstyle     = \bfseries\color{blue},
    stringstyle      = \color{codegreen},
    commentstyle     = \color{codegreen},
    showstringspaces = false,
    literate         = %
      {ρ}{{$\rho$}}1
      {ℓ}{{$\ell$}}1
      {∑}{{$\Sigma$}}1
      {Σ}{{$\Sigma$}}1
      {√}{{$\sqrt{}$}}1
      {θ}{{$\theta$}}1
      {ω}{{$\omega$}}1
      {ɛ}{{$\varepsilon$}}1
      {φ}{{$\varphi$}}1
      {σ²}{{$\sigma^2$}}1
      {Φ}{{$\Phi$}}1
      {ϕ}{{$\phi$}}1
      {Dₑ}{{$D_e$}}1
      {Σ}{{$\Sigma$}}1
      {γ}{{$\gamma$}}1
      {δ}{{$\delta$}}1
      {τ}{{$\tau$}}1
      {μ}{{$\mu$}}1
      {β}{{$\beta$}}1
      {Λ}{{$\Lambda$}}1
      {λ}{{$\lambda$}}1
      {r̃}{{$\tilde{\text{r}}$}}1
      {α}{{$\alpha$}}1
      {σ}{{$\sigma$}}1
      {π}{{$\pi$}}1
      {∈}{{$\in$}}1
      {∞}{{$\infty$}}1
}


%% Bibliographies %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\usepackage{natbib}
    %---For bibliographies
%\setlength{\bibsep}{3pt} % Set how far apart bibentries are

%% Misc %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{enumitem}
    %   Has to do with enumeration
\usepackage{appendix}
%\usepackage{natbib}
    %   For bibliographies
\usepackage{pdfpages}
    %   For including whole pdf pages as a page in doc
\usepackage{pgffor}
    %   For easier looping


%% User Defined %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\newcommand{\nameofcmd}{Text to display}
\newcommand*{\Chi}{\mbox{\large$\chi$}} %big chi
    %   Bigger Chi

% In math mode, Use this instead of \munderbar, since that changes the
% font from math to regular
\makeatletter
\def\munderbar#1{\underline{\sbox\tw@{$#1$}\dp\tw@\z@\box\tw@}}
\makeatother

% Misc Math
\newcommand{\ra}{\rightarrow}
\newcommand{\diag}{\text{diag}}
\newcommand{\proj}{\operatorname{proj}}
\newcommand{\ch}{\text{ch}}
\newcommand{\dom}{\text{dom}}
\newcommand{\one}[1]{\mathbf{1}_{#1}}


% Command to generate new math commands:
% - Suppose you want to refer to \boldsymbol{x} as just \bsx, where 'x'
%   is any letter. This commands lets you generate \bsa, \bsb, etc.
%   without copy pasting \newcommand{\bsa}{\boldsymbol{a}} for each
%   letter individually. Instead, just include
%
%     \generate{bs}{\boldsymbol}{a,...,z}
%
% - Uses pgffor package to loop
% - Example with optional argument. Will generate \bshatx to represent
%   \boldsymbol{\hat{x}} for all letters x
%
%     \generate[\hat]{bshat}{\boldsymbol}{a,...,z}

\newcommand{\generate}[4][]{%
  % Takes 3 arguments (maybe four):
  % - 1   wrapcmd (optional, defaults to nothing)
  % - 2   newname
  % - 3   mathmacro
  % - 4   Names to loop over
  %
  % Will produce
  %
  %   \newcommand{\newnameX}{mathmacro{wrapcmd{X}}}
  %
  % for each X in argument 4

  \foreach \x in {#4}{%
    \expandafter\xdef\csname%
      #2\x%
    \endcsname%
    {\noexpand\ensuremath{\noexpand#3{\noexpand#1{\x}}}}
  }
}


% MATHSCR: Gen \sX to stand for \mathscr{X} for all upper case letters
\generate{s}{\mathscr}{A,...,Z}


% BOLDSYMBOL: Generate \bsX to stand for \boldsymbol{X}, all upper and
% lower case.
%
% Letters and greek letters
\generate{bs}{\boldsymbol}{a,...,z}
\generate{bs}{\boldsymbol}{A,...,Z}
\newcommand{\bstheta}{\boldsymbol{\theta}}
\newcommand{\bsmu}{\boldsymbol{\mu}}
\newcommand{\bsSigma}{\boldsymbol{\Sigma}}
\newcommand{\bsvarepsilon}{\boldsymbol{\varepsilon}}
\newcommand{\bsalpha}{\boldsymbol{\alpha}}
\newcommand{\bsbeta}{\boldsymbol{\beta}}
\newcommand{\bsOmega}{\boldsymbol{\Omega}}
\newcommand{\bshatOmega}{\boldsymbol{\hat{\Omega}}}
\newcommand{\bshatG}{\boldsymbol{\hat{G}}}
\newcommand{\bsgamma}{\boldsymbol{\gamma}}
\newcommand{\bslambda}{\boldsymbol{\lambda}}

% Special cases like \bshatb for \boldsymbol{\hat{b}}
\generate[\hat]{bshat}{\boldsymbol}{b,y,x,X,V,S,W}
\newcommand{\bshatbeta}{\boldsymbol{\hat{\beta}}}
\newcommand{\bshatmu}{\boldsymbol{\hat{\mu}}}
\newcommand{\bshattheta}{\boldsymbol{\hat{\theta}}}
\newcommand{\bshatSigma}{\boldsymbol{\hat{\Sigma}}}
\newcommand{\bstildebeta}{\boldsymbol{\tilde{\beta}}}
\newcommand{\bstildetheta}{\boldsymbol{\tilde{\theta}}}
\newcommand{\bsbarbeta}{\boldsymbol{\overline{\beta}}}
\newcommand{\bsbarg}{\boldsymbol{\overline{g}}}

% Redefine \bso to be the zero vector
\renewcommand{\bso}{\boldsymbol{0}}

% Transposes of all the boldsymbol shit
\newcommand{\bsbp}{\boldsymbol{b'}}
\newcommand{\bshatbp}{\boldsymbol{\hat{b'}}}
\newcommand{\bsdp}{\boldsymbol{d'}}
\newcommand{\bsgp}{\boldsymbol{g'}}
\newcommand{\bsGp}{\boldsymbol{G'}}
\newcommand{\bshp}{\boldsymbol{h'}}
\newcommand{\bsSp}{\boldsymbol{S'}}
\newcommand{\bsup}{\boldsymbol{u'}}
\newcommand{\bsxp}{\boldsymbol{x'}}
\newcommand{\bsyp}{\boldsymbol{y'}}
\newcommand{\bsthetap}{\boldsymbol{\theta'}}
\newcommand{\bsmup}{\boldsymbol{\mu'}}
\newcommand{\bsSigmap}{\boldsymbol{\Sigma'}}
\newcommand{\bshatmup}{\boldsymbol{\hat{\mu'}}}
\newcommand{\bshatSigmap}{\boldsymbol{\hat{\Sigma'}}}

% MATHCAL: Gen \calX to stand for \mathcal{X}, all upper case
\generate{cal}{\mathcal}{A,...,Z}

% MATHBB: Gen \X to stand for \mathbb{X} for some upper case
\generate{}{\mathbb}{R,Q,C,Z,N,Z,E}
\newcommand{\Rn}{\mathbb{R}^n}
\newcommand{\RN}{\mathbb{R}^N}
\newcommand{\Rk}{\mathbb{R}^k}
\newcommand{\RK}{\mathbb{R}^K}
\newcommand{\RL}{\mathbb{R}^L}
\newcommand{\Rl}{\mathbb{R}^\ell}
\newcommand{\Rm}{\mathbb{R}^m}
\newcommand{\Rnn}{\mathbb{R}^{n\times n}}
\newcommand{\Rmn}{\mathbb{R}^{m\times n}}
\newcommand{\Rnm}{\mathbb{R}^{n\times m}}
\newcommand{\Rkn}{\mathbb{R}^{k\times n}}
\newcommand{\Cn}{\mathbb{C}^n}
\newcommand{\Cnn}{\mathbb{C}^{n\times n}}

% Dot over
\newcommand{\dx}{\dot{x}}
\newcommand{\ddx}{\ddot{x}}
\newcommand{\dy}{\dot{y}}
\newcommand{\ddy}{\ddot{y}}

% First derivatives
\newcommand{\dydx}{\frac{dy}{dx}}
\newcommand{\dfdx}{\frac{df}{dx}}
\newcommand{\dfdy}{\frac{df}{dy}}
\newcommand{\dfdz}{\frac{df}{dz}}

% Second derivatives
\newcommand{\ddyddx}{\frac{d^2y}{dx^2}}
\newcommand{\ddydxdy}{\frac{d^2y}{dx dy}}
\newcommand{\ddydydx}{\frac{d^2y}{dy dx}}
\newcommand{\ddfddx}{\frac{d^2f}{dx^2}}
\newcommand{\ddfddy}{\frac{d^2f}{dy^2}}
\newcommand{\ddfddz}{\frac{d^2f}{dz^2}}
\newcommand{\ddfdxdy}{\frac{d^2f}{dx dy}}
\newcommand{\ddfdydx}{\frac{d^2f}{dy dx}}


% First Partial Derivatives
\newcommand{\pypx}{\frac{\partial y}{\partial x}}
\newcommand{\pfpx}{\frac{\partial f}{\partial x}}
\newcommand{\pfpy}{\frac{\partial f}{\partial y}}
\newcommand{\pfpz}{\frac{\partial f}{\partial z}}


% argmin and argmax
\DeclareMathOperator*{\argmin}{arg\;min}
\DeclareMathOperator*{\argmax}{arg\;max}


% Various probability and statistics commands
\newcommand{\iid}{\overset{iid}{\sim}}
\newcommand{\vc}{\operatorname{vec}}
\newcommand{\Cov}{\operatorname{Cov}}
\newcommand{\rank}{\operatorname{rank}}
\newcommand{\trace}{\operatorname{trace}}
\newcommand{\Corr}{\operatorname{Corr}}
\newcommand{\Var}{\operatorname{Var}}
\newcommand{\asto}{\xrightarrow{a.s.}}
\newcommand{\pto}{\xrightarrow{p}}
\newcommand{\msto}{\xrightarrow{m.s.}}
\newcommand{\dto}{\xrightarrow{d}}
\newcommand{\Lpto}{\xrightarrow{L_p}}
\newcommand{\Lqto}[1]{\xrightarrow{L_{#1}}}
\newcommand{\plim}{\text{plim}_{n\rightarrow\infty}}


% Redefine real and imaginary from fraktur to plain text
\renewcommand{\Re}{\operatorname{Re}}
\renewcommand{\Im}{\operatorname{Im}}

% Shorter sums: ``Sum from X to Y''
% - sumXY  is equivalent to \sum^Y_{X=1}
% - sumXYz is equivalent to \sum^Y_{X=0}
\newcommand{\sumnN}{\sum^N_{n=1}}
\newcommand{\sumin}{\sum^n_{i=1}}
\newcommand{\sumjn}{\sum^n_{j=1}}
\newcommand{\sumim}{\sum^m_{i=1}}
\newcommand{\sumik}{\sum^k_{i=1}}
\newcommand{\sumiN}{\sum^N_{i=1}}
\newcommand{\sumkn}{\sum^n_{k=1}}
\newcommand{\sumtT}{\sum^T_{t=1}}
\newcommand{\sumninf}{\sum^\infty_{n=1}}
\newcommand{\sumtinf}{\sum^\infty_{t=1}}
\newcommand{\sumnNz}{\sum^N_{n=0}}
\newcommand{\suminz}{\sum^n_{i=0}}
\newcommand{\sumknz}{\sum^n_{k=0}}
\newcommand{\sumtTz}{\sum^T_{t=0}}
\newcommand{\sumninfz}{\sum^\infty_{n=0}}
\newcommand{\sumtinfz}{\sum^\infty_{t=0}}

\newcommand{\prodnN}{\prod^N_{n=1}}
\newcommand{\prodin}{\prod^n_{i=1}}
\newcommand{\prodiN}{\prod^N_{i=1}}
\newcommand{\prodkn}{\prod^n_{k=1}}
\newcommand{\prodtT}{\prod^T_{t=1}}
\newcommand{\prodnNz}{\prod^N_{n=0}}
\newcommand{\prodinz}{\prod^n_{i=0}}
\newcommand{\prodknz}{\prod^n_{k=0}}
\newcommand{\prodtTz}{\prod^T_{t=0}}

% Bounds
\newcommand{\atob}{_a^b}
\newcommand{\ztoinf}{_0^\infty}
\newcommand{\kinf}{_{k=1}^\infty}
\newcommand{\ninf}{_{n=1}^\infty}
\newcommand{\minf}{_{m=1}^\infty}
\newcommand{\tinf}{_{t=1}^\infty}
\newcommand{\nN}{_{n=1}^N}
\newcommand{\tT}{_{t=1}^T}
\newcommand{\kinfz}{_{k=0}^\infty}
\newcommand{\ninfz}{_{n=0}^\infty}
\newcommand{\minfz}{_{m=0}^\infty}
\newcommand{\tinfz}{_{t=0}^\infty}
\newcommand{\nNz}{_{n=0}^N}

% Limits
\newcommand{\limN}{\lim_{N\rightarrow\infty}}
\newcommand{\limn}{\lim_{n\rightarrow\infty}}
\newcommand{\limk}{\lim_{k\rightarrow\infty}}
\newcommand{\limt}{\lim_{t\rightarrow\infty}}
\newcommand{\limT}{\lim_{T\rightarrow\infty}}
\newcommand{\limhz}{\lim_{h\rightarrow 0}}

% Shorter integrals: ``Integral from X to Y''
% - intXY is equivalent to \int^Y_X
\newcommand{\intab}{\int_a^b}
\newcommand{\intzN}{\int_0^N}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% BODY %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{document}
%\maketitle
\lstset{style=log}

\tableofcontents

\clearpage
\section{General Computing and Programming}

\subsection{Computer \& Cluster Architecture}


\paragraph{Von Neumann or Princeton Architecture}
Abstract model of a computer consisting of
\begin{enumerate}
  \item (\emph{Central Processing Unit}):
    Performs and coordinates operations.

    Each CPU is a collection of processor \emph{cores} (usually
    physical), consisting of
    \begin{itemize}
      \item (\emph{Arithmetic Logic Unit or ALU}): Performs simple
        operations like plus, minus, times, division, and logical
        operations.
      \item (\emph{Control Unit}): Coordinates the operation and
        sequence of data movements between the other parts of the
        Architecture.
    \end{itemize}
    A single node/server/computer often has multiple CPUs, which we refer to
    as \emph{sockets}.

  \item (\emph{Memory}):
    Hardware involved in storing data and programs.
    Two flavors:
    \begin{itemize}
      \item (\emph{Random Access Memory or RAM}):
        Temporary memory, quick and easy to acess, used to execute
        programs. Also called volatile memory.
      \item (\emph{Lasting memory}):
        Non-volatile memory storage, e.g. hard drives.
    \end{itemize}
    Memory is managed by the operating system, which is one of its
    primary roles.
  \item Input \& Output
\end{enumerate}
\paragraph{Clusters}
\begin{itemize}
  \item Group of inter-connected computers that work together to perform
    computationally-intensive tasks.
  \item Each computer is a \emph{node}, so a cluster is a collection of
    nodes.
  \item Server (host) address is what we use to identify server we
    want to connect to using ssh
  \item
    Head Node(s)
    \begin{itemize}
      \item Server(s) that connects a cluster to an outside network (like
        the internet or a company's internal network).
      \item Handles login, script editing, code compilation, job submission.
      \item Generally don't want to run stuff here.
    \end{itemize}
  \item
    Compute Node
    \begin{itemize}
    \item Server used for computing, sometimes managed by a scheduler.
    \item Compute nodes \emph{always} contain RAM and one or more CPUs
      (usually two), each with multiple processor cores, on which
      computation may take place.

      If that's all they contain, they are a CPU (only) node.
      If they additionally have GPUs for carrying out computation, they
      are typically referred to as GPU nodes.
    \end{itemize}
  \item Schedulers help divide up the resources of a cluster and handle
    submission of jobs to the compute nodes.
\end{itemize}


\clearpage
\subsection{Types and Features of Computing Languages}

Compiled vs. Interpreted Paradigm
\begin{itemize}
  \item Compiler translates source code into machine code, or
    in Java's case, low level \emph{virtual} machine code called JVM
    code that is later translated into actual machine code.
  \item An interpreter simulates the operation of a (virtual) machine
    running your code.
    It evaluates code one line at a time.

    Python doesn't type check at compile time, only at run time.
\end{itemize}
Type Checking
\begin{itemize}
  \item Static (compile time) type checking, e.g. Java:
    All variables have declared types, and system checks for type
    errors at compile time
  \item Dynamic (run time) type checking, e.g. Python:
    Values, not variables, have defined types, and system checks for
    type errors at run time
\end{itemize}
Programming \& Language Styles
\begin{itemize}
  \item Procedural: Compiled language, source code describes execution
    of one instruction after another.
    C is the best example.
  \item Scripted:
    Interpreted language, commands that specify execution of one command
    after another.
  \item Special-Purpose:
    Optimized around certain datatypes
  \item Object Oriented:
    \begin{itemize}
      \item Distinct from procedural style
      \item Focus on objects that do things.
      \item Encapsulation:
        Hide information to make programs robust
      \item Type checking to avoid and find errors
      \item Libraries to reuse code
      \item Immutability to guarantee stability of program data
    \end{itemize}
    Examples: C++, Java
  \item Functional:
    \begin{itemize}
      \item Treat computation as the evaluation of functions
      \item Completely avoids side effects and mutable types
      \item Functions are first-class entities, can be arguments and return
        values
      \item Map: Take function and apply to all elements in sequence
      \item Reduce:
        Given function \texttt{f} and a list/sequence \texttt{L}, the
        command
        \begin{lstlisting}
          REDUCE(f, L)
        \end{lstlisting}
        returns
        \begin{lstlisting}
          f(L[0], REDUCE(f, L[1:end]))
        \end{lstlisting}
        and keeps going until there's no elements left in the list.

    \end{itemize}
    Examples: Haskell, OCaml
\end{itemize}




\clearpage
\subsection{Memory}

\subsubsection{Machine Level}


At the lowest level, computers work in \emph{bits}, which are 0's and
1's. From there, build up to
\begin{itemize}
  \item One byte is eight bits.
  \item A byte has $2^8=2^4\times 2^4 = 16\times 16$ possible
    configurations/values.
\end{itemize}
Each of the $16\times 16$ possible values of a byte can be represented
by two hexadecimal numbers.
\begin{itemize}
  \item Hexadecimal uses $0-9$ to represent the first ten digits, then
    adds on $A,B,C,D,E,F$ for 10, 11, 12, 13, 14, 15.
  \item Two hexadecimal numbers can encode $16\times 16$ values.
  \item Therefore, each value/configuration for a byte can be mapped
    into a two-digit hexadecimal number.
\end{itemize}
RAM
\begin{itemize}
  \item Objects in RAM are represented as a sequence of binary
    memory cells, \emph{bits}, which are organized into \emph{words}
    (groupings of several bits),
    which are the fundamental unit of data that can be moved between RAM
    and the processor.
    Typical sizes are 8, 16, 32, and 64 bit.

  \item The fact that bits are grouped into words allows for
    \emph{addressing} of memory.
    Each word has an address, which is the location of the word in the
    computer's memory.
    By working with addresses, we can have low-level access to
    the computer by allowing direct access to the memory.
    We know where things are.
    One can literally move through the computer's memory from word to
    word.

  \item The stack is the pile of variables in memory, one after the
    other.
    As we create variables, we ``stack'' them on top of each other in
    memory, i.e. place them next to each other in memory.
\end{itemize}


\clearpage
\subsubsection{Data Structures in Programming Languages}

Having described how information is stored in memory at the computer
level, we can start to describe how a programming language conceives of
memory.
\begin{itemize}
  \item (\emph{Machine Representation of a Value}):
    A particular arrangement/representation/configuration of memory
    (bits) to reflect the notion of a ``value.''

  \item (\emph{Value}):
    Abstraction of the machine representation of a value.
    There are multiple ways we might encode the same value.
    By referring to a ``value'', we ignore this complication.

    For example, the number 3 is a well-defined ``value'' that
    exists separately from how we represent that in machine code.

  \item (\emph{Literal}):
    Programming language representation of a
    value, e.g. in the statement \texttt{int a = 1234;}, \texttt{1234}
    is the literal.
    This is distinct from both the machine code representation (a bunch
    of 1's and 0's) and from the more abstract notion of a value (the
    number 1234).

  \item (\emph{Data type}): Set of permissable values \& methods
    (functions) operating on those values.

  \item (\emph{Primitive Data Types}):
    Built in.
    Efficient in sense that their values and methods map immediately to a
    machine representation and instructions.
    This is in contrast to ADTs, whose values need to be ``resolved'' to
    primitive data types.

    Primitive data types and their memory requirements, in Java:
    \begin{table}[htpb!]
    \centering
    \begin{tabular}{l|l}
      Primitive Data Type & Memory Usage \\\hline\hline
      \texttt{boolean}
        & 1 byte (even though we technically only need 1 bit)
        \\
      \texttt{char}   & 2 bytes
        \\
      \texttt{short}  & 2 bytes
        \\
      \texttt{int}    & 4 bytes
        \\
      \texttt{float}  & 4 bytes
        \\
      \texttt{long}   & 8 bytes
        \\
      \texttt{double} & 8 bytes
    \end{tabular}
    \end{table}

  \item
    (\emph{Abstract data types} or \emph{ADTs} aka \emph{Reference Types}):
    ``Higher-level'' data types whose representation is hidden from
    client (caller).
    Lets users use ADTs without knowing implementation details.
    Generally includes both built-in (e.g. \texttt{String} or arrays)
    and user-defined instances.
    Java refers to these as \emph{Reference Types}.

    We can see why primitive data types are more efficient than
    abstract/reference data types types.
    The latter are ultimately stored/encoded via primitive data
    types. So to get the value of an abstract/reference type, we need to
    translate/resolve it to the level of primitive data types.
    There's an extra step.


  \item (\emph{Data Structure}): Arrangement of data enabling
    efficient processing by a program.
\end{itemize}
Object-Oriented Framework:
In this framework, users create their own new ADTs and manipulate them.
Key concepts include
\begin{itemize}
  \item (\emph{Object}):
    A \emph{container} for values of a particular data type.
    It's distinct from the value itself because the value within the
    container/object can change through the application of various
    methods that operate on that value.

  \item (\emph{Object Reference}):
    An address/arrow \emph{referring} to some object.
    It is distinct from the object itself, from the value contained in
    the object, and from any name we might attach to the reference.
    We can pass it to or return it from a method.
    That way, we can just pass an address or ``way to find the
    value'' from program to program, which is much cheaper that passing
    around in memory an entire object or value.

    Java programs manipulate references to objects.

  \item (\emph{Variable}):
    Name to which we can attach/assign an object reference.
    This is distinct from the object reference itself (the arrow),
    the object, and the value contained in the object because,
    through reassignment, a given variable/name can have
    multiple/different object references associated with it.

  \item (\emph{Variable Declaration}):
    Associates variable (the name) with a data type (primitive or
    abstract).
    Must always declare a variable's name and type, e.g.
    in Java
    \begin{lstlisting}
      int a;
      String s;
      double[] x;
      SomeType varname;
    \end{lstlisting}
    This restricts the types of objects that a variable can refer to,
    i.e. restricts the types of object references (arrows) that we can
    attach to the name.

    Technically declaration and assignment can happen in one line, but
    there is an order to what happens that corresponds to how we would
    break things up.

    For primitive types, the variable refers directly to a value, i.e. a
    machine code representation of the value is directly attached to the
    variable name.
    For ADTs, the variable is attached to a reference to a value, i.e. an
    object reference is attached to the variable name.
    % Check this

  \item
    (\emph{Memory Allocation and Creating New Instances for ADTs}):
    For ADTs, after variable declaration (which merely associates the
    variable/name with a particular type), we must create an
    object of that type (i.e. allocate memory) via a constructor and
    associate the variable with that object by establishing an object
    reference.

    In Java, this requires using the \texttt{new} keyword followed by a
    call to a constructor for that reference type, e.g.
    \begin{lstlisting}
    x = new SomeType(args);
    \end{lstlisting}
    The constructor always shares the name of the type.

    After memory allocation, we can initialize the values.
    Memory allocation and initialization often happen in one step.
    Even more, declaration, memory allocation, and initialization can
    sometimes be done in one step, e.g. for an array,
    \begin{lstlisting}
    double[] x = new double[n];
    \end{lstlisting}

  \item (\emph{Assignment}):
    Associates a value with a variable.
    For primitive data types, assignment can happen right after or at
    the same time as type declaration.
    For reference types, assignment can happen right after declaration
    and memory allocation, or at the same time as both.

  \item
    (\emph{Invoking Instance Methods}):
    We can invoke instance methods that operate on the object's value,
    \begin{lstlisting}
    x = varname.methodname(args);
    \end{lstlisting}


  \item (\emph{Creating New Data Types}):
    Data type implementation is known as a \emph{class}.
    The code for a new datatype is stored in a \texttt{.java} file with
    the same name of the class.
    The code will have blocks/sections corresponding to the following.
    \begin{itemize}
      \item (\emph{Instance Variables}):
        These define the data type's values.
        It's the bundle/set of values that form ``the set of values that
        the object can take on.''
        In this section of the class definition, we declare those
        variables and associate them with a type.

        Declaration of these sometimes includes modifiers like
        \begin{itemize}
          \item \texttt{private}: Denies clients access to the variable
            and therefore makes the data type abstract.
          \item \texttt{final}: Disallows any change in the value after
            constructed and documents that the data type is immutable.
        \end{itemize}

      \item (\emph{Constructors}):
        Special method that necessarily has the same name as the
        class/ADT.
        It (potentially) takes arguments uses them to create a new
        object/instance, setting the instance variables in the process.
        Because the instance variables already had their types declared,
        no need to declare type of these within this method (unlike
        static methods).

        No return type declaration in the method signature because it
        always returns a \emph{reference} to the new object of the data
        type.

        When using/calling, must always use the keyword \texttt{new} to
        use a constructor and signify that we're creating a new
        object/instance of a given data type.

      \item (\emph{Instance Methods}): Like static methods, but distinct
        from them.
        They define data-type operations (implement APIs, work on the
        datatype values).
        They can refer to and operate on the instance variables.

      \item (\emph{Test Client}): Not strictly necessary, but good
        practice.
        This is the \texttt{main} function, which should call the
        constructor and run the methods to test them all out.

      \item (\emph{Other Static Methods}):
        In addition to the methods defined above, we can include static
        methods in the class definition.
        Unlike the other methods, they cannot refer to and operate on
        instance variables.
    \end{itemize}
    Example class that would be stored in \texttt{Charge.java}:
    \begin{lstlisting}
    public class Charge
    {
      // Instance variables
      private final double rx, ry;    // Position
      private final double q;         // Charge value

      // Constructor
      public Charge(double x0, double y0, double q0)
      {
        rx = x0;
        ry = y0;
        q  = q0;
      }

      // Methods
      public double potentialAt(double x, double y)
      {
        double k  = 8.99e09;
        double dx = x - rx;
        double dy = y - ry;
        return k * q / Math.sqrt(dx*dx + dy*dy);
      }

      public String toString()
      {
        return q + " at " + "(" + rx + ", " + ry + ")";
      }

      // Test client
      public static void main(String[] args)
      {
        Charge c = new Charge(.72, .31, 21.3);
        StdOut.println(c);
        StdOut.printf("%6.2e\n", c.potentialAt(.42, .71));
      }
    }
    \end{lstlisting}



  \item
    (\emph{Aliasing for Reference Types}):
    When we put a reference type on the RHS of an assignment statement,
    the variable on the LHS points to the same point in memory.
    We do not create a new object with the same values as the original
    on the RHS.
    Rather, we simply have a new reference to the same point in memory.
    Subsequent operations involving either the LHS or RHS of the
    assignment statement will operate on the same object in memory.

  \item Pass by value:
    When passing arguments to function, it's like we have a usual
    assignment statement, and thus there is aliasing for reference
    types.
    If the argument value is a primitive type, this means Java passes a
    copy of the value.
    If the argument value is a reference type, this means Java passes a
    copy of the object reference.

  \item An orphaned object is one that was created and had some
    reference pointing to it, but no longer.
    Java garbage collects, ensuring orphaned objects are
    cleared from memory.


\end{itemize}




\clearpage
\subsection{Input/Output}

Overview:
Terminals run shells. Shells can run/execute programs by
taking some inputs provided through an input stream (the terminal by
default) and then producing output that is then carried through an
output stream (which is directed to the terminal by default).

We now define these important input/output abstractions for delivering
to or receiving output from programs in more detail.
These abstractions let us focus on complying/interfacing with the
system, without having to worry about how the system ultimately
represents, outputs, gathers, etc. the text.
\begin{itemize}
  \item A stream is an abstraction for something that can transfer data,
    including (and especially) text.
    It is not the data itself, but rather the channel and ``ability to
    transfer.''
    So we can ``send data to a stream'' and the program or operating
    system will take care of the implementation details.

  \item In Linux, whenever a program/command is executed, three standard
    streams are created that data can pass through:
    \begin{itemize}
      \item \texttt{stdin}, Standard Input Stream:
        An abstraction for an infinite input sequence or a file
        containing infinite text.
        Takes text input and has the capacity to transfer that
        information to programs for execution.

        Reading from the standard input stream involves consuming and
        processing the text there.
        Note that the collection of pieces of text separated by
        whitespace are referred to as \emph{tokens}.

      \item \texttt{stdout}, Standard Output Stream:
        An abstraction for an infinite output sequence or a file
        containing infinite text.
        Has the capacity to transfer output from programs elsewehere,
        like other programs via pipes or the terminal (where it is sent
        by default).

      \item \texttt{stderr}:
        Errors
    \end{itemize}
    Java and other programming languages also have standard drawing and
    audio, much like standard input and ouptut.

  \item Command line input:
    An abstraction for providing arguments (strings) to a program.

  \item
    \emph{Terminal}:
    An \emph{abstraction} for providing input to and getting output from
    a program via the \texttt{stdin} and \texttt{stdout} streams by
    running a shell that can execute programs/commands.

    It works as follows.
    Type a text command, the terminal sends that text input to
    \texttt{stdin}.
    The shell the terminal is running transfers the data in
    \texttt{stdin} to given program which then executes low-level
    machine commands (like ``do these things'', ``run this program'',
    ``read this file'', etc.).
    After completion, the program sends data to the \texttt{stdout}
    stream, which by default, is directed to the terminal which then
    displays text, although it can be piped elsewhere.
    It's a way of working with files that are often nothing more than a
    stream of text.
\end{itemize}
Shells
\begin{itemize}
  \item A user interface for interacting with an operating system (via
    text commands which must conform to a certain standard/syntax) and
    carrying out low-level machine commands.
  \item Can use either a CLI (command line interface) or GUI (graphical
    user interface).
  \item It is the outermost layer around OS kernel.
  \item Windows computers use DOS shell prompts to interact with the
    system. Unix computers use BASH prompts.
  \item
    Redirection and Pipes:
    The shell gives the ability to redirect standard output of one
    program to standard input of another, i.e.\ change where the streams
    \texttt{stdin} and \texttt{stdout} are pointed (given that the
    default is the terminal).
    \begin{itemize}
      \item \texttt{>} and \texttt{>>}: Lets you redirect \texttt{stdout}
        (i.e. the text therein) that's produced by a program to any file.
        The former overwrites, the latter appends.

        Note that we can discard output entirely by sending output to the
        null device as follows:
        \lstset{style=bash}
        \begin{lstlisting}
        cmd > /dev/null 2>&1
        \end{lstlisting}
        where 2 is an alias for \texttt{stderr} and 1 for \texttt{stdout}.

      \item \texttt{<}: Redirects input from file into a program.
        Not used a lot since many commands take file arguments already.

      \item
        \texttt{cmd1 | cmd2}:	Pipes standard output from \texttt{cmd1} to
        standard input of \texttt{cmd2}.
    \end{itemize}
  \item Pipes are enormously useful because they allow programs to
    interact purely through the input and output streams.
    No two programs have to know about each other to be able to be wired
    together via pipe.
\end{itemize}




\clearpage
\subsection{Parallel Computing}

\href{https://princetonuniversity.github.io/PUbootcamp/sessions/parallel-programming/Intro_PP_bootcamp_2018.pdf}{Resource here}.
In contrast to serialization (execution of all computations one after
the other), can parallelize.
\\
\\
MPI (Message Passing Interface)
\begin{itemize}
  \item A standardized interface (like BASH)
  \item
    Can run many copies of the same program/task across many nodes (and
    cores) in a cluster, and MPI will pass messages to coordinate.
    Distributed memory.
  \item Multiple implementations:
    OpenMPI, MPICH, proprietary Intel implemntations, etc.
  \item Structure of a program
    \begin{lstlisting}
    #!include <mpi.h> // Include header file

    // Start of program
    int main (int argc, char argv*[])
    {

    // Non-interacting code
    ..

    // Initialize MPI
    // Must be called in every MPI program as first call
    MPI_Init(&argc, &argv);

    // Parallel code
    ..

    // End MPI environment
    MPI_Finalize();

    // More non-interacting code
    ..

    // End of program
    return 0;
    }

    \end{lstlisting}
\end{itemize}
OpenMP (Open Multi-Processing)
\begin{itemize}
  \item Run multiple threads on a single node, with each thread using
    one core. Shared memory.
  \item Not at all related to MPI
  \item Each program starts with a single process that has its own
    private memory space and can create one or more threads which share
    the memory of the parent process.
  \item Structure of a program
    \begin{lstlisting}
    #!include <omp.h> // Include header file

    // Start of program
    int main (int argc, char argv*[])
    {

    // Non-parallel code
    ..

    // Indicate that next code block should be executed in parallel
    #pragma omp parallel
    {
      ...
    }

    // Non-parallel code
    ..

    // End of program
    return 0;
    }

    \end{lstlisting}

  \item This is what Matlab parallelization uses under the hood
\end{itemize}
Define
\begin{align*}
  \text{(Parallel Efficiency)}
  =
  \frac{%
    \text{(Serial Execution Time)}
  }{%
    \text{(Parallel Execution Time per Task)}
    \times
    \text{(Number of Tasks)}
  }
\end{align*}




\clearpage
\section{UNIX Operating System}

\subsection{Unix File System}

Everything in Unix is essentially a file, and there are two types of
files:
\begin{itemize}
  \item Text: For human use/consumption
  \item Binary: For computer use/consumption
\end{itemize}

\subsection{Directory Structure and Management}

Files are organized into a heirarchy under the the root directory
\texttt{/}, owned/managed by a single root user who can edit everything
under this directory.
Under this root directory, we have
\begin{itemize}
  \item \texttt{/bin}: \emph{Essential} binary executables.
    Important system programs and utilities like bash are
    here.
    These are the crucial absolutely necessary things that are
    guaranteed to be mounted whenever \texttt{/} is mounted,
    irrespective of whether the \texttt{/usr} directory is mounted (as
    it can be stored on a separate partition).
    Used by the system, the system administrator, and users.

  \item \texttt{/sbin}: Like \texttt{/bin}, contains essential binaries
    that are generally intended to be run by \emph{system} and
    \emph{system administrator} for \emph{system maintenance} purposes.

  \item \texttt{/lib}:
    Libraries needed by the essential binaries in \texttt{/bin} and
    \texttt{/sbin}.

  \item \texttt{/usr}:
    Second level user binaries and read-only data.
    Non-essential applications and files used by \emph{users} as opposed
    to the system. Non-essential in the sense that if we mount
    \texttt{/}, we can still work with the system even we don't mount
    \texttt{/usr}.


    Has subdirectories similar to the subdirectories of \texttt{/}:
    \begin{itemize}
      \item \texttt{/usr/bin}:
        Binary files for user programs
      \item \texttt{/usr/lib}
      \item \texttt{/usr/sbin}
      \item \texttt{/usr/local/}:
        Locally compiled applications (i.e. built from source, not
        installed with APT or package manager) are installed here by
        default so as not to fuck up the rest of the system.
    \end{itemize}
  \item \texttt{/var}:
    Variable data files.
    Since \texttt{/usr} is read-only, log files and everything else that
    must be written are written here.
    System log files, emails, print queues, etc.


  \item \texttt{/root}:
    Home directory of the single root user.
    His home directory is \emph{not} just \texttt{/} or in
    \texttt{/home}.

  \item \texttt{/home}:
    Contains the home folders of all non-root users on the system.
    Each user of the system gets their own subfolder under
    \texttt{/home} with all their files.
  \item \texttt{/mnt}:
    Historically, where system admins mounted temporary file systems,
    although you can technically mount anywhere in the file system.
  \item \texttt{/media}:
    Contains subdirectories where removable media devices are mounted
    when inserted/connected.
  \item \texttt{/etc}:
    Configuration files required by all programs, can generally be
    edited by hand in a text editor.
  \item \texttt{/boot}:
    Contains files needed to boot the system, e.g. the GRUB files and
    the Linux kernels.
    Note, doesn't have the configuration files though. Those are all in
    \texttt{/etc}.
  \item \texttt{/tmp}:
    For storing temporary files. Deleted on restart or at any time.
  \item \texttt{/run}:
    Standard place for applications to store transient files they need.
    Not stored in \texttt{/tmp} because files there can be deleted.
  \item \texttt{/dev}:
    Note actual files, but they are ``files'' representing
    devices/hardware (like the hard drive).
    Also contains pseudo-devices like \texttt{rand} or \texttt{null}
    that generate random numbers or discard output piped to it,
    respectively.
  \item \texttt{/proc}:
    Contains special files that represent the system and process
    information.
    \texttt{/proc/(pid)} contains information about the process running
    with that pid.

  \item \texttt{/srv}: Service data containing data for services
    \emph{provided by} the system.
  \item \texttt{/opt}:
    Subdirectories for optional software packages.
    Commonly used by proprietary software that doesn't obey the standard
    Unix file system heirarchy and wants to do it's own thing.
    For example, the application ``application'' might just dumb all
    its files into \texttt{/opt/application/} rather than scatter it's
    files around in the various system directories as is standard.

  \item \texttt{/sys}:
    This directory has kernel parameters, exposed as files for the user
    to view, modify, and interact with like it's they are typical files.
    This has all the knobs for your computer.
\end{itemize}


\clearpage
\subsubsection{\texttt{chmod}}

The syntax is roughly
\begin{lstlisting}
  chmod <ugo><+-><rwx> path/to/file.txt
\end{lstlisting}
Note
\begin{itemize}
  \item \texttt{u} is user, \texttt{g} is group, \texttt{o} is other.
  \item \texttt{+} or \texttt{-} add/remove permissions
  \item \texttt{r} is read, \texttt{w} is write, and \texttt{x} is
    write
\end{itemize}


\clearpage
\subsection{BASH}

 By default, Linux uses BASH.


\subsubsection{Environment}

An environment is essentially just the collection of \emph{settings} for
your particular session.
For example, when executing commands in a terminal running BASH, these
settings help tell the shell how to interpret and execute commands
(e.g.\ what compiler to run, where to look for programs and packages,
etc.).

It is represented by \emph{environment variables}, which encode those
settings for a particular shell session.
\begin{itemize}
  \item \texttt{\$HOME}:
    Reserved variable for the home directory;
    \texttt{~} gets expanded to this.
  \item \texttt{\$PS1}: Appearance of the command prompt string
  \item \texttt{\$PATH}:
    Variable that evaluates to a list of directory names separated by
    colons and specifying the directories in which the shell looks for
    commands.

    Can add to this path via
    \lstset{style=bash}
    \begin{lstlisting}
    export PATH=/new/dir/:$PATH
    \end{lstlisting}
    Whenever you type a command, the shell looks in those dirs, in
    order, to determine what executable to run.
    The command
    \texttt{which <command>}
    tells you the precise path of the executable that is being used, if
    there are multiple (e.g. multiple Python installations).

    Be careful always to \emph{append} or \emph{prepend} when modifying
    \texttt{\$PATH}. Don't reset entirely.
\end{itemize}




\clearpage
\subsection{Utilities}

Utilities are programs or tools that do things.
We invoke them in Unix via the command line interface, typing commands
into the terminal, which are then interpreted by the shell and prompt
the computer to do a thing.

This section will therefore detail those tools/utilities and the text
commands that invoke/control them.

\subsubsection{\texttt{rsync}}

A powerful utility for transferring many files with the potential to
resume a broken connect

\subsubsection{\texttt{sed}}

Stream editor that takes a stream of text pulled from a file or
\texttt{stdout} via a pipe.


\subsubsection{\texttt{grep}}

Take a regular expression and return any line in the file that matches
the expression.


\subsubsection{Installation and Package Management}

\paragraph{From Source}
\begin{itemize}
  \item Download files, usually a zip or tarball. Extract.

  \item CD into the directory, which contains all the source files.
    Often there's a README or install file. Read that, see if there's
    anything distinctive about this install.

  \item Configure:
    Typically, you first run \texttt{./configure}, which checks the
    system for the software and packages needed to build the program.

    Resolve dependences with APT or by installing other packages
    from source. Rerun \texttt{./configure}.

    Might need to do this multiple times until \texttt{./configure} runs
    through successfully.

  \item Compile:
    Run the command \texttt{make} to compile source code into binary.

  \item Install:
    Run \texttt{sudo make install} to use the compiled files to install.
    Files are probably stored under \texttt{/usr/local/}

  \item Uninstall:
    Run \texttt{sudo make uninstall}.

  \item Updating (Lack Thereof):
    No easy way to update packages this way.
    Need to uninstall and reinstall.
    That's why it's best to use a package manager.
    See below.
\end{itemize}


\clearpage
\paragraph{APT, DPGK, and Package Management}
APT (Advanced Packaging Tool).
This is a more-user friendly wrapper of Debian's package manager DPGK.
Comprehensive reference
\href{https://www.digitalocean.com/community/tutorials/ubuntu-and-debian-package-management-essentials}{here}.
\begin{itemize}
  \item Packages: A discrete unit of software containing user
    interfaces, modules, libraries.
    Want to install, use, and possibly uninstall these.

  \item Repositories/PPAs:
    Remote software archives where downloadable packages are listed,
    along with both download information and update information (e.g.
    when the last update was).
    This determines my visible universe of packages that are available
    to download or update with APT.\footnote{%
      There are other packages to download in non-added repositories
      that I can't see, and there lots of other packages that I could
      download source code for and install. But I can't see these or
      interact with them through APT since I haven't added them to my
      source list.
    }
    Adding a repository/PPA will expand the list of APT-downloadable
    packages (without actually downloading or installing anything).

    The configuration file \texttt{/etc/apt/sources.list}
    and files in \texttt{/etc/apt/sources.list.d/}
    have a list of all sources/repositories with available downloads.
    These files can be edited manually or using commands described
    below.

    By having a list pointing to remote sources/repositories with
    downloadable packages/updates and update information,
    it's extremely easy to download packages, query/check for updates,
    and install updates.
    This wouldn't be as easy if we had to downloaded the packages and
    install them from source in one shot, without storing
    \emph{sources}/\emph{repositories}.

    The term ``repositories'' is generally used for official/traditional
    sources, while PPAs refers to ``personal package archives'' which
    are generally smaller in scope and very targeted in the types of
    programs/software contained in them, unlike the broader traditional
    repostories.
    Although in practice, there's no difference for downloading,
    installing, etc.

  \item Local Database of Packages:
    APT keeps a local database of packages along with information about
    whether any updates for my installed packages are available.

  \item Searching all sources/repositories for packages using keywords:
    This queries all the sources/repositories listed in
    \texttt{/etc/apt/sources.list} to see if there are any packages
    whose descriptions involve keywords:
    \lstset{style=log}
    \begin{lstlisting}
apt-cache search [keywords]
    \end{lstlisting}

  \item Adding repositories:
    Can directly edit \texttt{/etc/apt/sources.list} or place a new
    list in \texttt{/etc/apt/sources.list.d/}.
    Alternatively and preferably use
    \begin{lstlisting}
add-apt-repository [repository name]
    \end{lstlisting}
    Note that the repository name might be of the form
    \texttt{ppa:ownername/ppaname}, indicating that it's a PPA rather
    than a big official/traditional repository. Although this
    distinction doesn't really matter.

  \item Updating Sources:
    After adding repositories, update the package lists (the local
    database of downloadable/updatable packages) for all of my
    repositories and check for updates in one shot with
    \begin{lstlisting}
    sudo apt-get update
    \end{lstlisting}
    This will also list out all servers where information is being
    retreived from in the course of updating.

  \item Installing a Package:
    To install a package, use
    \begin{lstlisting}
    sudo apt-get install [packagename]
    \end{lstlisting}
    Will sometimes also install related packages and dependencies
    (prerequisite packages).

    Add \texttt{-s} flag to run a ``simulated'' install.

    Add \texttt{-f} and omit \texttt{[packagename]} if the install
    failed because of dependency issues.
    This will search for any unsatisfied dependences and try to install
    them in an attempt to fix the dependency tree.

  \item Removing a Package and Configuration Files:
    To get rid of a package and its dependencies, use
    \begin{lstlisting}
    sudo apt-get remove [packagename]
    \end{lstlisting}
    Note however that an installed package also often has various
    configuration files and associated directories that won't be needed
    after the package has been uninstalled.
    To remove these \emph{also} (so you don't have to manually delete),
    modify the above command to
    \begin{lstlisting}
    sudo apt-get remove --purge [packagename]
    \end{lstlisting}

  \item Cleaning Up Unused Dependencies:
    Some installed packages were only installed because they were
    dependencies for other packages that might now be uninstalled.
    If there any unused dependencies that aren't associated with an
    installed program still hanging around, use the following command to
    remove them:
    \begin{lstlisting}
    sudo apt-get autoremove
    \end{lstlisting}
    Can also add \texttt{--purge} argument to remove their configuration
    files and associated directories.

  \item Upgrading Packages:
    First, always make sure you did an update before doing an upgrade.
    Next, to replace old packages with their updated selves, run
    \begin{lstlisting}
    sudo apt-get upgrade
    \end{lstlisting}
    The above command takes an installed package, removes it, and
    replaces it with one of the exact same name.
    No new packages installed, no packages uninstalled.
    This can be an issue.

    Sometimes an updated package requires a new dependency or requires
    removing one dependency and replacing it with a different one with a
    different name.
    The above command will not take care of these dependency issues
    since it cannot install or uninstall anything.
    So instead run the following command which can resolve these
    potential dependency issues.
    \begin{lstlisting}
    sudo apt-get dist-upgrade
    \end{lstlisting}
    Of course, this is a little more aggressive and we should use this
    with care probably.

  \item Cleaning up the Cached Downloaded Packages:
    Even after a package is downloaded and installed, the download is
    still cached in case the system needs to reference it.
    They are never automatically deleted even if a package is
    redownloaded and reinstalled after an update. The new download will
    be cached in addition with the old one still there.

    The following command deletes all cached downloads
    \begin{lstlisting}
    sudo apt-get clean
    \end{lstlisting}
    The following command deletes all cached downloads, except the most
    recent for each package. So it just ditches old versions.
    \begin{lstlisting}
    sudo apt-get autoclean
    \end{lstlisting}

  \item Querying Installed Packages:
    To get a list
    \begin{lstlisting}
    sudo dpkg --list
    \end{lstlisting}

  \item Installing \texttt{.deb} Packages:
    Sometimes a software vendor will just supply a deb file.
    After downloading to the current directory, we can install with
    \begin{lstlisting}
    sudo dpkg --install debfile.deb
    \end{lstlisting}
    Note that the \texttt{dpkg} command doesn't resolve dependencies, so
    if there are unmet dependencies, installation will typiclly fail.
    However, it will mark them, and we can use \texttt{apt-get} to fix
    them by running the following command, which will install unmet
    dependencies:
    \begin{lstlisting}
    sudo apt-get install -f
    \end{lstlisting}

  \item Show Dependencies and Reverse Dependencies:
    List all packages listed as a hard dependency, suggestion,
    recommendation, conflict to a given package,
    \begin{lstlisting}
    apt-cache depends [packagename]
    \end{lstlisting}
    List what \emph{depends on} the given package
    \begin{lstlisting}
    apt-cache rdepends [packagename]
    \end{lstlisting}

  \item Show Installed and Available Versions of a Package:
    Often many versions of a package within the repositories, with a
    single default.
    To see the version installed, the candidate to be installed unless
    otherwise specified, and a table of versions, run
    \begin{lstlisting}
    apt-cache policy [packagename]
    \end{lstlisting}


  \item Tracing Package Files:
    To see which files a package installed (not including configuration
    files),
    \begin{lstlisting}
    dpkg -L package
    \end{lstlisting}
    To see what package installed a file, run
    \begin{lstlisting}
    dpkg -S /path/to/file
    \end{lstlisting}

\end{itemize}


\clearpage
\subsubsection{Slurm Scheduler}

Scheduling software for high performance computing clusters.
To run, you need
\begin{itemize}
  \item A job to run (python script, R script, Matlab job, compiled
    executable)
  \item
    A SLURM script (often suffixed \texttt{.cmd}, \texttt{.slurm} or
    \texttt{.sh} by convention but not necessarily)
\end{itemize}
Serial jobs use only a single processor, while parallel jobs use more
than one processor.

\paragraph{Command Line Commands}
Commands:
\lstset{style=bash}
\begin{lstlisting}
sbatch <slurm_script>         # Submit a job (e.g., sbatch job.slurm)
squeue                        # Show jobs in the queue
squeue -u <NetID>             # Show jobs in the queue for a specific user (e.g.,
squeue -u <NetID> --start     # Report the expected start time for pending jobs
squeue -j <JobID>             # Show the nodes allocated to a running job
scancel <JobID>               # Cancel a job (e.g., scancel 2534640)
scontrol show <JobID>         # See detailed info about a job
snodes                        # Show properties of the nodes on a cluster
                              # (e.g., maximum memory)
sinfo                         # Show how nodes are being used
sshare/sprio                  # Show the priority assigned to jobs
smap/sview                    # Graphical display of the queues
slurmtop                      # Text-based view of cluster nodes
scontrol show config          # View default parameter settings

sacct -o MaxVMSizeNode,ReqMem -j <JobID>    # View details about finished jobs.
                                            # Use sacct -e to view list options.


# See all jobs with associated priorities
squeue -o "%.18i %Q %.9q %.8j %.8u %.10a %.2t %.10M %.10L %.6C %R" | more

\end{lstlisting}



\paragraph{Scripts}
More or less Bash scripts (using the scripting syntax built into Bash)
with some extra parameters to help out slurm.
\lstset{style=bash}
\begin{lstlisting}
#!/bin/bash
#SBATCH --job-name=slurm-test    # create a short name for your job
#SBATCH --nodes=1                # node count, how many to claim (>1 for multinode jobs)
                                # If >1, executable must be coded explicitly
                                # to use MPI
#SBATCH --ntasks=1               # total no. of tasks across all nodes; 1 per core by default
                                # Total cores used = nodes * ntasks
#SBATCH --cpus-per-task=1        # cpu-cores per task (>1 for multicore jobs)
                                 # If >1, executable must be coded explicitly
                                 # to use multi-threading (e.g. to use OpenMP)
#SBATCH --mem-per-cpu=4G         # memory per cpu-core (4G is default)
#SBATCH --time=00:01:00          # total run time limit (DAYS-HH:MM:SS)
#SBATCH --mail-type=begin        # send email when job begins
#SBATCH --mail-type=end          # send email when job ends
#SBATCH --mail-user=<YourNetID>@princeton.edu

echo 'Hello world!'
\end{lstlisting}
Note
\begin{itemize}
  \item Make sure your slurm script loads any dependencies or path
    changes (i.e.\ you need python3, so \texttt{module load anaconda3}).

    Do not put the module load modulename command in your shell's
    startup script (e.g., \texttt{.bashrc}) as it can lead to difficult
    to diagnose problems.  Instead, use the module command in your Slurm
    submission scripts and the module will be loaded when the job is
    run.
  \item Make sure you call your executable with its full path or cd to
    the appropriate directory.
\end{itemize}


\paragraph{Output}
As a slurm job runs, unless you redirect output, a file named
\texttt{slurm-jobid.out} will be produced in your home directory.
It contains the output your program would have written to a terminal, if
run interactively.

Local scratch (i.e., /tmp) refers to the local disk physically attached
to each compute node on a cluster. This is the fastest storage available
to a job while it's running, so it's good to write there while a job is
working, and then copy the output from that node to another location
upon completion of the computations, before the job ends, e.g.
\begin{lstlisting}
#!/bin/bash
#SBATCH -N 1
#SBATCH -c 16
#SBATCH -t 1:00:00

export ScratchDir=``/tmp/myjob''
mkdir -p $ScratchDir
./a.out $ScratchDir

cp -r $ScratchDir /tigress/your_netid/
\end{lstlisting}


\paragraph{Iteractive Testing}
For interactive testing on compute nodes, can use \texttt{salloc}, which
takes the same modifiers as follow the \texttt{\#SBATCH} in your SLURM
script. But it instead sends you in an interactive shell to the compute
node once the allocation is granted.
Example
\begin{lstlisting}
salloc --nodes=1 --ntasks=1 --time 00:20:00
\end{lstlisting}
This asks for an allocation of 1 node, 1 task, and 20 minutes. Once it's
granted you'll be in a shell where you can run processes directly that
will be killed after the time elapses.


\paragraph{Easy Parallelization via Array Jobs}
You can write your executable to take as input an argument corresponding
to some index of an array of parameter values, after which the program
executes using that parameter value.
SLURM can be used to execute the program in parallel for each value in
the array.



\clearpage
\subsubsection{Modules}


Your environment is configured in a certain way with particular values
of the environment variables, corresponding to certain settings and
defaults and dependencies.
The \texttt{module} utility is useful for times when we want to
change/configure our environment in a way that makes it easier to use a
particular software package.
\begin{itemize}
  \item \texttt{module avail}:
    Lists all of the available modules that you can optionally load into
    your environment.
  \item \texttt{module load anaconda3}:
      Loads the module anaconda and configures your local environment.

      Then if you install new Python packages or upgrade old ones, when
      you reload the anaconda module, these updates and new packages
      will be there in your local environment.

  \item \texttt{module show <module-name>}:
      Will show you the steps/commands that are executed to set the
      environment, i.e. the sequence of environment variable changes or
      additions.

  \item \texttt{module list}:
    List out which modules are loaded.

  \item \texttt{module unload <modulename>}:
    Unload a module
\end{itemize}
Do not put the module load modulename command in your shell's startup
script (e.g., \texttt{.bashrc}) as it can lead to difficult to diagnose
problems.  Instead, use the module command in your Slurm submission
scripts and the module will be loaded when the job is run.




\clearpage
\subsection{Quick List of Useful Commands}


\begin{lstlisting}
    Quick List of Useful Commands and Utilities
    -------------------------------------------
    which <command>         # show path of command (e.g., which gcc)
    env                     # list all environment variables/settings
    echo $USER              # print contents of shell variable USER
    ehco $PATH              # print contests of shell variable PATH
    history                 # Print list list of recent commands (in .bash_history)


    # Server Commands
    hostname                  # get the name of the machine you are on
    whoami                    # get username of the account
    date                      # get the current date and time
    pwd                       # print working directory
    cat /etc/os-release       # info about operating system
    lscpu                     # info about the CPUs on head node
    who                       # list users on the head node

    # Princeton Server Commands
    snodes                    # info about the compute nodes (7 nodes for myadroit)
    squeue                    # which jobs are running or waiting to run
    qos                       # quality of servce (job partitions and limits)
    slurmtop                  # shows a map of cluster usage
    checkquota                # view your quota and request more space
\end{lstlisting}




\clearpage
\section{SQL (Structured Query Language)}

\subsection{Introduction}



Data Modeling:
Consists of the following steps.
\begin{itemize}
  \item Define \emph{entities}/\emph{concepts} that we want to capture
    data about, e.g.  persons, employees, customers, producers, etc.
    There will be a table associated with each entity/concept
  \item Determine \emph{attributes} of each entity/concept.
    These will be the columns in the table associated with each
    entity/concept.
  \item Determine \emph{relationships} between entities/concepts, e.g.
    customers \emph{buy from} producers.
  \item Determine \emph{cardinality}/\emph{multiplicity} of the
    relationship: 1:1, 1:M, M:M
\end{itemize}
Data modeling is typically done with \emph{ER Diagrams}.
The diagrams have a box for each entity, a line for each relationship,
and specific notation for the cardinality.
There are a few choices for that notation.
\begin{itemize}
  \item Chen Notation:
    Use 1:M, M:N, 1:1 for one-to-many, many-to-many, and
    one-to-one.
  \item Crow's Foot Notation:
    Train tracks and crow's foot to represent one and many.
  \item UML Class Diagram Notation:
    1.1 and 1.* to represent one and many.
\end{itemize}
The process of data modeling is an abstract task distinct from the
question of how we might collect, store, and represent the data.
We often store data in \emph{databases}, which are containers (file or
set of files) to store organized data, a set of related information.
Our database often consists of \emph{tables}, which are structured list
of data or a specific type.
They consist of of \emph{columns} (single fields in a table) and
\emph{rows} (records in a table).

Relational database model
\begin{itemize}
  \item This is one implementation for a given data model
    that is specifically designed for querying.
  \item Each entity has a table, attributes of an entity are stored in
    columns.
  \item Primary Key:
    Column or set of columns whose values unique identify every row in a
    table.
    Lets us use these to join to another table.
  \item Foreign Key:
    One or more columns that can be used together to identify a single
    row in another table.
\end{itemize}
NoSql (Not Only SQL)
\begin{itemize}
  \item Relational data model
  \item Mechanism for storage and retrieval of unstructured
    data model by means \emph{other than} tabular relations in
    relational databases.
\end{itemize}

%Transactional database model:
%Operational database.
%Not specifically designed for querying


\clearpage
\subsection{Basic Syntax}
\begin{itemize}
  \item Terminate commands with semicolon

  \item Comments:
    \begin{lstlisting}
    - - To comment out a single line

    /*
    To comment out
    multiple lines
    */
    \end{lstlisting}

  \item \texttt{NULL} is special entry.
    Null values are distinct from just ``empty string.''
    They really are ``nothing there.''

\end{itemize}


\subsection{Select Statements}

Select statements are the core of SQL.
They are how we retreive data.
The most basic select statement retrieves specific columns from a table.
\begin{lstlisting}
SELECT col1,
       col2
FROM tableName;
\end{lstlisting}
Can use $*$ as wildcard to retrieve all columns in the table.
\\
\\
At its most complex, we can augment the select statement with many
modifiers that refine the select statement.
\begin{lstlisting}
- - Selects columns to be returned
SELECT col1, col2

- - Specifies table where columns are
FROM tableName

- - Row-level filter (prior to any grouping)
WHERE

- - Group specification if we have an aggregate function in select statement
GROUP BY

- - Group-level filter
HAVING

- - Output sort order
ORDER BY
\end{lstlisting}



\clearpage
\subsubsection{Row-wise Operations}

For numeric data, can use simple math operations in select statement:
\begin{lstlisting}
SELECT col1,
       col2,
       col1 * col2 AS newName
FROM tableName;
\end{lstlisting}
For string data, can use string functions in select statements
\begin{itemize}
  \item
    Concatenate with \texttt{||}, which is like using + in Python for
    strings.
    \begin{lstlisting}
    SELECT CompanyName,
           ContactName,
           Company Name || ',' || ContactName
    FROM Customers;
    \end{lstlisting}

  \item
    Trim with \texttt{TRIM}, \texttt{LTRIM}, \texttt{RTRIM}.
    This removes leading or trailing whitespace.
    \begin{lstlisting}
    SELECT TRIM(CompanyName) AS TrimmedName
    FROM Customers;
    \end{lstlisting}

  \item
    Use \texttt{SUBSTR} return specified number of characters from a
    particular position of a given string.
    Arguments are string name, starting position in string, number of
    characters to be returned.
    \begin{lstlisting}
    SELECT first_name, SUBSTR(first_name, 2, 3)
    FROM employees;
    \end{lstlisting}

  \item
    Use \texttt{UPPER}, \texttt{LOWER}, \texttt{UCASE} to change case.
    \begin{lstlisting}
    SELECT UPPER(column_name)
    FROM table_name;
    \end{lstlisting}
\end{itemize}
For strings that are specifically dates and/or times, there are
additional date-time functions.
\begin{itemize}
  \item
    Standard formats:
    All are encoded as strings.
    \begin{itemize}
      \item \texttt{DATE}: YYYY-MM-DD
      \item \texttt{DATETIME}: YYYY-MM-DD HH:MI:SS
      \item \texttt{TIMESTAMP}: YYYY-MM-DD HH:MI:SS
    \end{itemize}

  \item
    For converting birthdate to a year, month, day, time etc.:
    \begin{lstlisting}
    SELECT Birthdate,
           STRFTIME('%Y', Birthdate) AS Year,
           STRFTIME('%m', Birthdate) AS Month,
           STRFTIME('%d', Birthdate) AS Day
    FROM Employees
    \end{lstlisting}
    Compute current date and derivatives thereof
    by using \texttt{'now'}.
    \begin{lstlisting}
    SELECT DATE('now')

    SELECT STRFTIME('%Y %m %d', 'now')
    \end{lstlisting}
\end{itemize}
Case Statements:
Mimics if-then-else.
Produce a new column where each record/row is built from an if
statement based on the values in the other columns for that row.
\begin{lstlisting}
SELECT col1,
       col2,
       col3,
       NewColName
CASE col1
  WHEN 'SomeVal1' THEN 'SetToWhen1'
  WHEN 'SomeVal2' THEN 'SetToWhen2'
  ELSE                 'SetToOther'
END NewColName
FROM TableName;
\end{lstlisting}
Alternatively
\begin{lstlisting}
SELECT col1,
       col2,
       col3,
       NewColName
CASE
  WHEN col1='SomeVal1' THEN 'SetToWhen1'
  WHEN col1='SomeVal2' THEN 'SetToWhen2'
  ELSE                      'SetToOther'
END NewColName
FROM TableName;
\end{lstlisting}
Note, what comes after \texttt{THEN} doesn't always have to be a
word or a number, can be a field from another column.



\clearpage
\subsubsection{Filtering with \texttt{WHERE}}

Filtering reduces the amount of rows that are pulled according based
on certain rules and logical conditions.
We do so by adding a \texttt{WHERE} line to the select statement.
\begin{lstlisting}
SELECT col1,
       col2
FROM tableName
WHERE logical-condition;
\end{lstlisting}
This pulls those rows for which the logical condition is satisfied.
The logical condition can be built using any of the following
approaches or keywords.
\begin{itemize}
  \item Comparisons:
    The logical condition might be phrased
    \begin{lstlisting}
    colName someOperator someValue
    \end{lstlisting}
    Ooperators include:
    \texttt{=},
    \texttt{!=},
    \texttt{>},
    \texttt{<},
    \texttt{BETWEEN} (beteween an inclusive range),
    \texttt{IS NULL}.

  \item \texttt{IN}:
    Restrict to those rows where a given column is in some set.
    \begin{lstlisting}
    SELECT col1,
            col2
    FROM tableName
    WHERE colName IN (val1, val2, val3);
    \end{lstlisting}

  \item \texttt{OR}:
    Non-inclusive matching.
    This is like \texttt{IN} but with precedence.
    \begin{lstlisting}
    SELECT col1,
            col2
    FROM tableName
    WHERE colName = val1 OR val2;
    \end{lstlisting}
    If there are some rows matching \texttt{val1}, it will return
    those rows and \emph{will not} retreive rows matching
    \texttt{val2}.
    If there are no rows matching \texttt{val1}, it will try to
    match \texttt{val2} and return rows matching that.
    So order matters; it specifies precedence.

    Use parentheses when working with \texttt{AND} because of order
    of operations.

  \item \texttt{AND}:
    Works like you think.
    Use parentheses when used with \texttt{OR} to be safe.

  \item \texttt{NOT}:
    Place in front of condition to return rows not matching that
    condition, e.g.
    \begin{lstlisting}
    SELECT col1,
            col2
    FROM tableName
    WHERE NOT colName = val1;
    \end{lstlisting}

  \item
    \texttt{LIKE}:
    Allows use of wildcards for matching text data.
    \begin{lstlisting}
    SELECT col1,
            col2
    FROM tableName
    WHERE colName LIKE '%partofstring';
    \end{lstlisting}
    Use \texttt{\%} anywhere in the string to match any number of
    characters.
    Use \texttt{\_} to match a single character.

    NOTE: These are slower. Other operators are preferred.
\end{itemize}



\subsubsection{%
  Grouping/Aggregating with \texttt{GROUP BY} and \texttt{HAVING}
}

\begin{itemize}
  \item Aggregate Functions:
    Built in functions used to summarize data.
    Includes
    \texttt{AVG()},
    \texttt{COUNT()},
    \texttt{MIN()},
    \texttt{MAX()},
    \texttt{SUM()}.
    Not that \texttt{NULL} values are ignored.

    We use a select statement with an \texttt{AS} to give the returned
    column/info a name:
    \begin{lstlisting}
    SELECT AVG(col1) as newName
    FROM tableName;
    \end{lstlisting}
    Note, can also use math expressions in place of a single column:
    \begin{lstlisting}
    SELECT AVG(col1*col2) as newName
    FROM tableName;
    \end{lstlisting}
    Use \texttt{DISTINCT} if we just want to use distinct entries of a
    column (non-duplicates).

  \item Grouping:
    \begin{lstlisting}
    SELECT col1,
           COUNT(col2) as newName
    FROM tableName
    GROUP BY col1;
    \end{lstlisting}
    \emph{Every} column in select statement must then be present in a
    \texttt{GROUP BY} clause, except for those columns that are purely
    arguments to aggregate functions (and so are, by definition,
    aggregated by group).
    So it's clear \texttt{GROUP BY} can contain multiple columns.

  \item
    Filtering after Grouping:
    \texttt{WHERE} does not work for groups because it filters on rows
    of the table (i.e. prior to group), not on grouped data (i.e. after
    grouping).  Instead, use \texttt{HAVING} to filter the grouped data.
    \begin{lstlisting}
    SELECT CustomerID,
           COUNT(*) as orders
    FROM OrderTable
    GROUP BY CustomerID
    HAVING COUNT (*) >=2;
    \end{lstlisting}
    This groups by CustomerID, counts the number of orders, and retains
    only those CustomerID with more than two orders.

    Can use both \texttt{WHERE} and \texttt{HAVING} to filter before
    grouping, and then filter after grouping.
    Note: rows eliminated by the \texttt{WHERE} clause will not be
    included in the group.

\end{itemize}


\subsubsection{Sorting with \texttt{ORDER BY}}

Sort returned data by sorting on (potentially multiple) columns.
We do so by adding lines to a select statement.
It must always be the last clause in the select statement.
Note that we can even sort on columns not selected for returning.
\begin{lstlisting}
SELECT col1,
        col2
FROM tableName
ORDER BY colX, colY, colZ
;
\end{lstlisting}
Can also add \texttt{ASC} or \texttt{DESC} before a particular
column name to specify ascending or descending order for the sort.




\clearpage
\subsection{Joins and Unions}


Joins retrieve data from multiple tables in one query.
Doesn't store joined information or have a phsyical effect;
join persists only for the duration of the query execution.

\begin{table}[htbp!]
\scriptsize
\centering
\begin{tabular}{|ccc|ccc|c|c|c|c|}
  \hline
  \multicolumn{3}{|c|}{Table 1}
  &
  \multicolumn{3}{|c|}{Table 2}
  &
  \multicolumn{4}{|c|}{Join Type}
  \\
  \hline
  \texttt{id} & \texttt{x1} & $\cdots$ &
  \texttt{id} & \texttt{y1} & $\cdots$
  & Inner
  & Left
  & Right
  & Outer
  \\
  \hline
  1 & & &
  1 & & &
  $\checkmark$ & $\checkmark$
  & $\checkmark$
  & $\checkmark$
  \\
  2 & & &
  2 & & &
  $\checkmark$ & $\checkmark$
  & $\checkmark$
  & $\checkmark$
  \\
  3 & & &
    & & &
    & $\checkmark$ &
  & $\checkmark$
  \\
  4 & & &
    & & &
    & $\checkmark$ &
  & $\checkmark$
  \\
    & & &
  5 & & &
    & &
    $\checkmark$
  & $\checkmark$
  \\
    & & &
  6 & & &
    & &
    $\checkmark$
  & $\checkmark$
  \\
  \hline
\end{tabular}
\end{table}


\subsubsection{Aliasing and Prequalifying}

Instead of writing out the table names all the times, we can create
aliases that we use elsewhere in the query.
\begin{lstlisting}
SELECT vendor_name,
       product_name,
       product_price
FROM Vendors v, Products p
WHERE v.vendor_id = p.vendor_id;
\end{lstlisting}
When performing joins, we will often ``qualify'' by
prepending to a given column name either the full table name (e.g.
\texttt{TableName.}) or that table's alias (e.g. \texttt{T1.}) if we
defined an alias for that table.
This is always allowed, and is good practice and/or necessary if two
tables that we're merging have columns with the same name or if
we're doing a self join.


\subsubsection{Inner Join}

Match on a key (unique identifier in both tables) and throw out any
unmatched records/rows in either table; the key needs to be in both.
We specify the columns we want from the two tables, the two tables
to join, and the key that is used to establish a match.
Only returns those records for which the key is found in \emph{both}
tables.
\begin{lstlisting}
SELECT Suppliers.CompanyName,
        ProductName,
        UnitPrice
FROM Suppliers INNER JOIN Products
  ON Suppliers.supplierid = Products.supplierid;
\end{lstlisting}


\subsubsection{Left and Right Joins}

Left Join:
Returns \emph{all} records from left table and the matched records
from the right table.
The key only needs to be in the left table.
Result is \texttt{NULL} if no match, rather
than throwing out as for an inner join.
\begin{lstlisting}
SELECT C.CompanyName,
        O.OrderID
FROM Customers C LEFT JOIN Orders O
  ON C.CustomerID = O.CustomerID;
\end{lstlisting}
Right Join: Similar to left join, just flipped.
The key only needs to be in the right table.
Given the abilitity to produce left joins, this type of join is
redundant since we can always just switch the order of the tables in the
join statement.

\subsubsection{Full Outer Join}

Return all records when there is a match in either the left
\emph{or} the right table records. ``Give me everything.''
The key only needs to be in one of the tables.
\begin{lstlisting}
SELECT Customers.CustomerName,
       Orders.OrderID
FROM Customers FULL OUTER JOIN Orders
  ON Customers.CustomerID = Orders.CustomerID;
\end{lstlisting}



\subsubsection{Cartesian (Cross Joins)}

Each row from first table joins with all the rows of another table.
So if Table 1 has $N_1$ rows and Table 2 has $N_2$ rows, result will
have $N_1\times N_2$ rows.
Specify all columns that you want from either table, and use
\texttt{CROSS JOIN} to list the two tables containing those columns.
Doesn't match on anything; just weirdly mashes together the two
datasets. Unclear  why you'd ever want to do this.
\begin{lstlisting}
SELECT product_name,
       unit_price,
       company_name
FROM suppliers CROSS JOIN products;
\end{lstlisting}


\subsubsection{Self Joins}

Join table to itself. Requires using aliases.
\begin{lstlisting}
SELECT A.CustomerName AS CustomerName1,
       B.CustomerName AS CustomerName2,
       A.City
FROM Customers A, Customers B
WHERE A.CustomerID = B.CustomerID
  AND A.City = B.City
ORDER BY A.City;
\end{lstlisting}
Alias the single table \texttt{Customers} by \texttt{A} and
\texttt{B}, effectively treating as two separate tables.
Not clear what this does or why you'd ever want to do this.


\subsubsection{Unions}

Combine the result-set of two or more select statements.
Essentially just stack one on top of the other.
Need to ensure the same number of columns and data types in each
column.
\begin{lstlisting}
SELECT colnames
FROM Table1

UNION

SELECT colnames
FROM Table2;
\end{lstlisting}


\clearpage
\subsection{Subqueries, i.e. Nesting Select Statements}

Subqueries are queries embedded in other queries; no limit to amount of
nesting.
Allows merging and filtering of entries in one table using
information in another table.
Notion of ``query expansion'' where innermost query evaluated and
work to outer query.
\begin{lstlisting}
SELECT customerID,
        companyName,
        Region
FROM CustomerTable
WHERE customerID IN (
                      SELECT customerID
                      FROM OrdersTable
                      WHERE Freight > 100
                    )
;
\end{lstlisting}
Another example that does a ``calculated fill'' (calculates and
fills).
\begin{lstlisting}
SELECT customer_name,
        customer_state
        (
        SELECT COUNT (*) AS orders
        FROM OrdersTable
        WHERE OrdersTable.customer_id = CustomersTable.customer_id
        ) AS orders
FROM CustomersTable
ORDER BY Customer_name
;
\end{lstlisting}
From \texttt{OrdersTable}, count the number of entries with a
\texttt{customer\_id} that is also in \texttt{CustomersTable};
this counts the number of orders for each customer in
\texttt{CustomersTable}.
Save the column as \texttt{orders}.






\clearpage
\subsection{Creating Tables and Views}

\begin{itemize}
  \item
    \texttt{CREATE TABLE}:
    Specify the table name, the column names,
    the data types, which column is a primary key, and
    whether we allow null values.
    \begin{lstlisting}
    CREATE TABLE TableName
    ( Id      char(10)        PRIMARY KEY,
      Col1    char(250)       NOT NULL,
      Col2    decimal(8,2)    NOT NULL,
      Col3    Varchar(750)    NULL );
    \end{lstlisting}

  \item \texttt{DROP TABLE}:
    Delete tables that are no longer needed
    \begin{lstlisting}
    DROP TABLE TableName;
    \end{lstlisting}


  \item
    \texttt{INSERT INTO}:
    To add a row/record into various columns of the table,
    \begin{lstlisting}
    INSERT INTO TableName
    ( '143423',
      'Matthew',
      '3.14',
      NULL );
    \end{lstlisting}
    Better is to specify specifically the columns that the data is
    intended for:
    \begin{lstlisting}
    INSERT INTO TableName
    ( Id,
      Col1,
      Col2,
      Col3 )
    VALUES
    ( '143423',
      'Matthew',
      '3.14',
      NULL );
    \end{lstlisting}

  \item
    \texttt{UPDATE}:
    Modify the rows in a table,
    \begin{lstlisting}
    UPDATE PhoneBook
    ( phone,
      firstname,
      lastname,
      address )
    VALUES
    ( '+1 610 582 7884',
      'Matthew',
      'Cocci',
      '333 Maple Street' )
    WHERE firstname = 'Matthew'
      AND lastname  = 'Cocci';
    \end{lstlisting}

  \item \texttt{DELETE FROM}:
    Delete the rows in a table,
    \begin{lstlisting}
    DELETE FROM PhoneBook
    WHERE firstname = 'Matthew'
      AND lastname  = 'Cocci';
    \end{lstlisting}

  \item
    \texttt{CREATE TEMPORARY TABLE}:
    Retrieve data and create a tempororary table (faster than creating a
    regular table). It stays around for the duration of the client
    session, and is then deleted.
    \begin{lstlisting}
    CREATE TEMPORARY TABLE NewTempTableName AS
    (
      select-statement
    )
    \end{lstlisting}

  \item Views:
    Essentially a stored query, but it will be removed after database
    connection has ended. You're not actually reading or writing to
    database; you're just simulating it.

    Basic syntax:
    \begin{lstlisting}
    CREATE [TEMP] VIEW [IF NOT EXISTS] ViewName[column_name_list]
    AS
    select-statement;
    \end{lstlisting}
    \texttt{TEMP} is optional specification of whether a view is
    temporary or not. \texttt{IF NOT EXISTS} is an optional
    specification of what to do if the view doesn't exist.

    After creating a view, we can use the view name as a table name in
    select statements, and proceed as if the view really were a table.

    To drop the view after we're done,
    \begin{lstlisting}
    DROP VIEW ViewName;
    \end{lstlisting}

\end{itemize}



\subsection{Miscellaneous}

\texttt{LIMIT}:
To limit the amount of rows pulled to obtain a sample.
\begin{lstlisting}
SELECT col1,
      col2
FROM tableName
LIMIT 5
;
\end{lstlisting}




\section{Algorithms}

\subsection{Guiding Principles}

We adopt the following guiding principles for analyzing
algorithms:
\begin{enumerate}
    \item \emph{Worst case analysis}: We analyze the worst
	case running time of an algorithm given the most
	difficult input the algorithm will half to handle. 
	It makes \textbf{no} assumptions about the input.
	This is in contrast to \emph{average case analysis},
	which considers the running time for the ``average''
	case, taking account of the relative frequencies of 
	certain inputs.
    \item Don't pay attention to constant factors and
	lower order terms. Different programming languages
	and compiling schemes will lead varying constant
	factors by a small amount. It's just inappropriate
	to worry about it unless the code is crucial to
	your task.
    \item Asymptotic Analysis: Focus on running time for 
	large input sizes $n$.
\end{enumerate}
Putting these three guiding principles together, we can
define a ``fast'' algorithm as one whose worst-case 
running time grows slowly with the input size,
where ``slowly'' in the best case scenario is typically
\emph{linear} growth in running time with increasing size, $n$.
In effect, that's the Holy Grail---the best-case running time
that we'll shoot for.


\subsection{Divide and Conquer Algorithms}

Divide the problem into smaller sub-problems, solve recursively,
where a \emph{recursive algorithm} is an algorithm that calls itself.


\subsubsection{Merge Sort}

Merge sort solves the \emph{sort problem}, where you want to 
order a unsorted list, by a divide-and-conquer, recursive
approach.

\paragraph{Pseudo-Code}
Merge Sort works as follows:
\begin{enumerate}
    \item Split the list in half into two sub-lists.
    \item Recursively sort the first half. Then, 
	recursively sort the second half.
    \item Merge/recombine the smaller sorted lists.
	\begin{enumerate}
	    \item You step through the output array, 
        populating it with the minimum 
        number from the two sorted sublists you're
        trying to recombine.
	    \item Implicit in the process, the minimum 
		element of each sublist is at the
		beginning of each sublist, so you don't
		have to waste time searching through them.
	\end{enumerate}
\end{enumerate}
Why is this better? Well, it runs with an upper bound
of 
    \[ \text{operations} \leq 6n \log_2 n + 6n \]
while Insertion Sort, Bubble Sort, selection sort, and 
other's require $n^2$ operations. We'll see where this comes 
from later, but for now, just note this running time
is pretty good, even though it's not quite linear since at $6n \log_2 n$.


\paragraph{Runtime Analysis}
{\sl Simplifying Assumptions}:
    Suppose we have a list of length
    $n$ where, for simplicity, we assume $n$ is a
    power of 2 such that $j = \log_2 n$. 
    \\
    \\
{\sl Recursive Structure Tree}:
    We will make $\log_2 n = j$ divisions of 
    the original list into sub-lists: dividing the original
    list in half, dividing the first level of two sublists in
    half again for a total of four sublists at the second
    level, etc. This will generate a tree with $j$ levels.
    \\
    \\
    Within our tree, at each specific level, $k$, we have 
    $2^k$ sub-problems, with each problem of size
    $n/2^k$.  There are $2^k$ sub-problems because
    we divide by two at each step down the tree.
    On top of that, the sub-problems are
    of size $n/2^k$ because with each division of a 
    parent problem, we reduce the size of the problem 
    by one half.
    \\
    \\
{\sl Merging Sublists}:
    Now, when the Merge Sort has to merge two sub-lists 
    to form a list of size $m$, it will use at most
    $6m$ steps (by a rough approximation that you
    can figure out by looking at the code or pseudocode
    for merging).
    \\
    \\
{\sl Operations at Level $j$}:
    Combining previous results, we see that the number of 
    steps at level $j$ turns out to be:
    \[ \text{operations at level $j$} \leq 
	\underbrace{2^j}_{\text{No. of level $j$ sub-probs}} 
	\times \underbrace{6}_{\text{Merge steps}}
	\underbrace{\left(n/2^j\right)}_{\text{Sub-prob size
	at level $j$}} = 6n \]
    This is awesome because the number of operations
    required at level $j$ is \emph{independent} of the level!
    \\
    \\
{\sl Total Runtime}:
    This means that we take the work per level just computed
    $6n$, times the number of levels:
    \[ \text{total operations} \leq \underbrace{6n}_{\text{work per level}}
	\times \underbrace{\left( \log_2 n +1\right)}_{\text{number of levels}}
	\]



\clearpage
\subsection{Dynamic Connectivity Problem}

Dynamic Connectivity Problem
\begin{itemize}
  \item Setup
    \begin{itemize}
      \item $N$ objects possibly connected
      \item ``Is connected to'' is an equivalence relation.
      \item Connected Components:
        We can partition the set of all objects based on the equivalence
        relation into ``connected components'', i.e. maximal subsets that
        are mutually connected.
      \item Find/connected query: Is there a path connecting the two
        objects?
      \item Union command: Connects two objects.
        If those objects are components, replace the components with
        their union.
    \end{itemize}
  \item Quick-Find, which is an eager approach
    \begin{itemize}
      \item Have an id array of size $N$.
        $p$ and $q$ connected if they share an id.
      \item Find: Check if they have the same id
      \item Union: To merge components containing $p$ and $q$, change
        all entries with $id(p)$ to $id(q)$.
      \item Problem: For loop to change the ids, so lots of looping.
        Maximum number of accesses during union operation scales with
        $N^2$
    \end{itemize}
  \item Quick-Union, which is a lazy approach (try to avoid work until
    we have to)
    \begin{itemize}
      \item Have an id array of size $N$.
        $id(i)$ is the parent of $i$.
        Can recursively access to get to the ``root.''
        Picture trees.
      \item Find: Check if $p$ and $q$ have the same root.
      \item Union: To merge components containing $p$ and $q$,
        set $p$'s root to the id of $q$'s root.
      \item Problem: Too tall trees since you need to recurse all the
        way back to the root.
        Maximum number of accesses during find scales with $N$.

      \item Improvement:
        Modify to avoid tall trees.

        Track size of trees and always link root of smaller tree to root
        of larger tree, not vice versa.
        Depth of any node of $x$ is at most $\log_2 N$, which scales
        nicely.

        Can also, as you work up the tree on a find, rebind each node in
        a tree to the root, rather than leave bound to parent.
        This ``flattens'' the tree.

    \end{itemize}
  \item Can be proved that it is very nearly linear time, but there is
    no exactly linear time algorithm.
\end{itemize}
Percolation
\begin{itemize}
  \item $N\times N$ grid of sites that are either open with probability
    $p$ or blocked with probability $1-p$.
  \item A system \emph{percolates} if and only if top and bottom are
    connected by open sites.
\end{itemize}



\clearpage
\appendix
\section{Princeton Clusters}

\begin{lstlisting}
Nobel
- Good for interactive work
- Two nodes, Davisson and Compton
- No separation into head/login node and compute node

Adroit
- HPC that's useful for bigger job
- Batch submission

Perseus, Tiger, Della, Traverse:
- HPC research clusters with many nodes
- GPFS networked storage between clusters



File System for Tiger Cluster. Same as Perseus, Tiger, Della, Traverse
----------------------------------------------------------------------
/home/mcocci      Store source code, executables, and backed-up files.
/scratch/gpfs     Job output & intermediate files here, "volatile files"
/tigress/mcocci   Insanely large file system for storing final results
                  (non-volatile files). Connected to all clusters.
                  Backed up. But slow to get data here, so don't ever
                  write here directly.

Note that all of these directories are kept on separate disks.

Note that each compute node also has a /scratch directory.

All servers and storage are linked by Omni-Path high speed network.



File System for Adroit Cluster
------------------------------
/home/mcocci      Store source code, executables, and backed-up files.
/scratch/network  Job output & intermediate files here, "volatile files"




Modules
-------
By default, the Princeton server loads old Python when you run
\texttt{python}.
To get the newer Anaconda Python implementation, load the modeule

  module load anaconda3
  conda list

with the last commmand listing all available packages.



To install packages to a given module,

  module load anaconda3
  pip install --user <package>

which installs to ~/.local/lib/python<version>/site-packages
\end{lstlisting}




\section{Java Cheatsheet}

Terminology, Jargon, and Key Definitions
\begin{itemize}
  \item Static method: ``Static method'' is the Java name for a
    function. Takes zero or more input arguments, returns zero or one
    output value, and perhapse causes some side effects (which is what
    makes Java functions more general than mathematical functions).

  \item Class: Set of static methods that we want to group together.
    Always has a \texttt{main()} function. See work flow below for
    its role.

  \item Module: All of the source code that's kept in a single file
    forms a module; the module is the file (contents).
    By convention, each module consists of one single class, and the
    name of this file is the name of this class, plus a
    \texttt{.java} extension.

    Later on, modules implement data types.

  \item Library: Module whose methods/functions are primarily intended
    for use by many other programs.
    It is a set of functions.

  \item Client: Program that calls a given library method.

  \item API: Clear and concrete specification of the methods
    in module/library---what's available and what they do.
    At its most basic, it's just a listing of all methods, the
    arguments and argument types those methods take, and the type of
    output they return.

  \item Implementation: The Java code that implements the methods in
    an API.
\end{itemize}
Work Flow
\begin{itemize}
  \item Source code for a given module all saved in a single
    \texttt{.java} file.
    This module defines a class, say \texttt{myprogram}, in which
    case we typically name the source code file
    \texttt{myprogram.java}.
    The contents of the file will look like
    \lstset{style=log}
    \begin{lstlisting}
    public class myprogram
    {
      public static void main(String[] args)
      {
        // Comments
        StdOut.println("Hello, World");
      }
    }
    \end{lstlisting}
  \item Compile the module/class via \texttt{javac myprogram.java},
    which creates the Java bytecode file \texttt{myprogram.class}.
  \item Execute or run with \texttt{java myprogram}.
    Here Java transfers control to the machine code corresponding to
    the \texttt{main()} method defined in the \texttt{myprogram.java}
    file/module that was compiled into the binary
    \texttt{myprogram.class}.
\end{itemize}

\clearpage



\clearpage
Arrays (a type of data structure)
\begin{itemize}
  \item Sequence of values all of the same type
  \item Arrays store information in a blocked portion of memory, using
    the data types to determine how much memory to allocate.
  \item Accessing elements of array are very efficient because you go to
    the first location in memory, then increment by \texttt{i} times the
    size of the primitive data type to get to the memory location of
    element \texttt{i}.
  \item Array Declaration
    \begin{lstlisting}
      double[] a;
    \end{lstlisting}
    The brackets make clear that \texttt{a} is a double \emph{array},
    not just a scalar.
  \item Array creation/Memory Allocation and Assignment/Initialization:
    \begin{lstlisting}
      a = new double[10];
    \end{lstlisting}
    Default initialization to zero.
  \item Can declare, create, initialize in one step:
    \begin{lstlisting}
    double[] a = new double[10];
    \end{lstlisting}
    Can also initialize to literal values rather than default via
    \begin{lstlisting}
    double[] a = {0.3, 0.6, 0.1};
    \end{lstlisting}
  \item Two dimensional arrays (in row-major order)
    \begin{itemize}
      \item Doubly indexed sequence of values. First index is the
        ``row'' (the array within the big array) while second index the
        ``column''
      \item They are represented as arrays of arrays.
      \item Hence each row can have a different number of elements
      \item Hence also easy to extract a row since it just pulls the
        $r$th array, but no easy way to access a given column since
        elements of a column are spread across arrays.
    \end{itemize}
\end{itemize}


\clearpage
\subsection{Input/Output}
Input/Output
\begin{itemize}
  \item Command line input: An abstraction for providing arguments
    (strings) to a program.

    Every module/class has a \texttt{main()} method (invoked
    automatically when a program is run by the \texttt{java}
    command), which takes a string array \texttt{args[]} as
    argument, which corresponds to the commands we type to invoke
    the program.  Need to use \texttt{Integer.parseInt()} to convert
    strings to numbers if we wish to use them as numbers.

  \item Standard Output Stream:
    An abstraction for an infinite output sequence.
    Sent to terminal application by default.

    We can add strings to the end of the standard output stream with
    \begin{itemize}
      \item \texttt{System.out.print(String s)}
      \item \texttt{System.out.println(String s)}
      \item \texttt{System.out.println()}
      \item \texttt{System.out.printf(String format, \dots)}
    \end{itemize}
    Alternatively, we can use the \texttt{StdOut} library developed for
    the course, which implements abstractions developed for Unix and
    which has methods
    \begin{itemize}
      \item \texttt{StdOut.print(String s)}
      \item \texttt{StdOut.println(String s)}
      \item \texttt{StdOut.println()}
      \item \texttt{StdOut.printf(String format, \dots)}
    \end{itemize}
    These methods are the same as using \texttt{System.out}, but more
    convenient because they gather all I/O abstractions in one place
    and in a way that's more system, language, locale independent.

  \item
    Standard Input Stream:
    An abstraction for an infinite input sequence.

    We can use the \texttt{StdIn} library developed for the course,
    which implements abstractions developed for Unix.
    Takes data from standard input stream, which contains a sequence
    of values separated by whitespace.
    Reading from the standard input stream involves consuming and
    processing the text there.
    Note that the collection of pieces of text separated by
    whitespace are referred to as \emph{tokens}.

    There are methods for reading the entirety of the standard input
    stream
    \begin{itemize}
      \item \texttt{String readAll()}: Read all input and return as
        string.
      \item
        \texttt{String readAllLines()}: Read all remaining lines and
        return as string array.
      \item
        \texttt{int[] readAllInts()},
        \texttt{double[] readAllDoubles()},
        and so on
        will read the remaining tokens and attempt to return them
        as an \texttt{int} , \texttt{double}, etc. array.
    \end{itemize}
    There are also methods for reading single lines,
    \begin{itemize}
      \item \texttt{boolean hasNextLine()}
      \item \texttt{String readLine()}
    \end{itemize}
    Reading single characters,
    \begin{itemize}
      \item \texttt{boolean hasNextChar()}
      \item \texttt{String readChar()}
    \end{itemize}
    Reading individual tokens (portions separated by whitespace from
    other tokens)
    \begin{itemize}
      \item \texttt{boolean isEmpty()}:
        Is standard input empty or only whitespace
      \item
        \texttt{int readInt()},
        \texttt{double readDouble()}, etc.:
        Read next token, convert to int, double, etc., and return
        it.
    \end{itemize}

  \item
    Java also has standard drawing and audio, much like standard input
    and ouptut.
    More info
    \href{https://introcs.cs.princeton.edu/java/10elements/}{here}.
\end{itemize}









\clearpage
Fuctions/Methods
\begin{itemize}
  \item Flow control for a function call
    \begin{enumerate}
      \item Control transers to the function code
      \item Argument variables are declared and initialized with the
        given values
      \item Function code executed
      \item
        Pass-by-Value:
        Control transfers back to calling code, with return value
        assigned in place of the function name in the calling code.
    \end{enumerate}
  \item The signature (first line of a static function definition)
    has the following features
    \begin{itemize}
      \item Either \texttt{public} or \texttt{private} to mark the
        class or method as available for use by another program.
      \item \texttt{static}
      \item Return Type:
        \texttt{void} (if it returns nothing),
        \texttt{double} (if it returns a value of type
        \texttt{double}),
        etc.
        We must specify the return type.
      \item Function Name
      \item Arguments/Parameter Variables:
        Note that we must declare the types of the parameter
        variables.
    \end{itemize}

  \item
    Scope:
    The scope of a variable is teh code that can refer to a variable by
    name.
    Variables declared/created within a static function are local to
    that static function.
    Keep scope tight.

  \item Overloading:
    Static methods with different signatures are different static
    methods. In other words, Java allows overloading, i.e. the
    same function name can have different behavior depending upon
    the number and types of arguments passed to that function name.

  \item Pass-by-Value:
    Static functions in Java are pass by value.

  \item
    Within a module, we can refer to methods in the same class using
    simply the method name.  We can refer to methods in \emph{other}
    classes/libraries by prepending the class name, i.e.
    \texttt{OtherClass.someMethod()}.
\end{itemize}





\clearpage
\subsection{Asymptotic Notation}

\subsubsection{Performance}

Performance
\begin{itemize}
  \item
    Tilde Notation:
    Use only the fasted growing terms; ignore slower growing terms.
    \begin{align*}
      f(N)\sim g(N)
      \quad\iff\quad
      \limN
      \frac{f(N)}{g(N)}
      = 1
    \end{align*}

  \item
    Order of Growth:
    Like tilde notation, but drop constants, i.e. don't require that the
    ratio converges to 1, just to some constant.

  \item Power law:
    Something like $aN^b$.
    Most programs satisfy something like this.

  \item
    If your program satisfies a power law $aN^b$, we can quickly compute
    $b$.
    First run the program for some size to get some time $T_0$; then
    double it, rerun, and record the time to get $T_1$.
    Take ratio $T_1/T_0 =2^b$, solve for $b$.

  \item
    Order of growth categories
    \begin{itemize}
      \item Linear $N$: If you have a for loop
      \item Quadratic $N^2$: Two forloops (nested)
      \item Cubic $N^3$: Three forloops (nested)
      \item Logarithmic $\log N$: When you split up the problem, solve
        half, split up, solve half of that
      \item Linearithmic $N\log N$: When you split up the problem, solve
        half, split up, solve half of that with a for loop in there.
    \end{itemize}

  \item
    Can't afford to use a quadratic or worse algorithm to address a
    problem with increasing size $N$ because they fall behind as the
    problem size increases.
\end{itemize}








\subsubsection{Big-Oh Notation}

This is a type of asymptotic notation concerning functions
defined on the positive integers. In particular, 
we'll consider a function $T(n)$, $n=1,2,\ldots$.
\\
\\
{\sl Definition}: A function $T(n) = O(f(n))$ if
and only if
\begin{equation} 
    \exists \; c, n_0 >0 \quad \text{s.t.} \quad 
    T(n) \leq c \; f(n) \quad \forall n \geq n_0
\end{equation} 
In words, $T(n)$ is $O(f(n))$ if $T(n)$ is 
bounded by a constant multiple of $f(n)$ 
for sufficiently large $n$.

\paragraph{Polynomial Functions}

We want to prove that Big-Oh notation really does
supress constant and lower order terms:
\begin{align}
    \text{if} \quad T(n) &= a_k n^k + \cdots + a_1 n + a_0 \notag\\
    \Rightarrow \quad T(n) &= O(n^k) \label{polynom}
\end{align}

\begin{proof} To prove, we need to find a $c$ and $n_0$
so that Equation \ref{polynom} satisfies the definition. 
So let's go.
\begin{align*}
    T(n) &= a_k n^k + \cdots + a_1 n + a_0 \\
    &\leq |a_k| n^k + \cdots + |a_1 | n + |a_0| \\
    &\leq |a_k| n^k + \cdots + |a_1 | n^k + |a_0|n^k \\
    &\leq \sum_{i=0}^k |a_i| n^k \\
    \Rightarrow \quad n_0=1 \quad & \quad c = \sum_{i=0}^k |a_i| 
\end{align*}
This satisfies the definition for $T(n)=O(n^k)$.
\end{proof}

\subsubsection{Omega Notation}

{\sl Definition}: We say that $T(n)=\Omega(f(n))$ if 
and only if there exist constants $c$ and $n_0$
such that 
    \[ T(n) \geq c\cdot f(n) \quad \forall n\geq n_0 \]

\subsubsection{Theta Notation}

{\sl Definition}: We say that $T(n) =\Theta(f(n))$ if
and only if $T(n)=O(f(n))$ AND $T(n) = \Omega(f(n))$.
Visually, this means $T(n)$ is ``sandwiched''
between two different constant multiples of $f(n)$.
\\
\\
Equivalently, $T(n) =\Theta(f(n))$ if and only if
\[ \exists c_1, c_2, n_0 \quad \text{s.t.}
    \quad c_1 \cdot f(n) \leq T(n) \leq c_2 \cdot f(n)
    \qquad \forall n\geq n_0 \]
Although, we typically only care about Big-Oh notation,
since we care abot upper bounds.

\subsubsection{Little-Oh Notation}

Similar to Big-Oh, but a little bit stronger. 
Formally, $T(n) = o(f(n))$ if and only
if for \emph{all} constants $c>0$, there exists 
a constant $n_0$ such that
    \[ T(n) \leq c\cdot f(n) \qquad \forall n \geq n_0 \]










\end{document}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%% SAMPLE CODE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    %% VIEW LAYOUT %%

        \layout

    %% LANDSCAPE PAGE %%

        \begin{landscape}
        \end{landscape}

    %% BIBLIOGRAPHIES %%

        \cite{LabelInSourcesFile}  %Use in text; cites
        \citep{LabelInSourcesFile} %Use in text; cites in parens

        \nocite{LabelInSourceFile} % Includes in refs w/o specific citation
        \bibliographystyle{apalike}  % Or some other style

        % To ditch the ``References'' header
        \begingroup
        \renewcommand{\section}[2]{}
        \endgroup

        \bibliography{sources} % where sources.bib has all the citation info

    %% SPACING %%

        \vspace{1in}
        \hspace{1in}

    %% URLS, EMAIL, AND LOCAL FILES %%

      \url{url}
      \href{url}{name}
      \href{mailto:mcocci@raidenlovessusie.com}{name}
      \href{run:/path/to/file.pdf}{name}


    %% INCLUDING PDF PAGE %%

        \includepdf{file.pdf}


    %% INCLUDING CODE %%

        %\verbatiminput{file.ext}
            %   Includes verbatim text from the file

        \texttt{text}
            %   Renders text in courier, or code-like, font

        \matlabcode{file.m}
            %   Includes Matlab code with colors and line numbers

        \lstset{style=bash}
        \begin{lstlisting}
        \end{lstlisting}
            % Inline code rendering


    %% INCLUDING FIGURES %%

        % Basic Figure with size scaling
            \begin{figure}[h!]
               \centering
               \includegraphics[scale=1]{file.pdf}
            \end{figure}

        % Basic Figure with specific height
            \begin{figure}[h!]
               \centering
               \includegraphics[height=5in, width=5in]{file.pdf}
            \end{figure}

        % Figure with cropping, where the order for trimming is  L, B, R, T
            \begin{figure}
               \centering
               \includegraphics[trim={1cm, 1cm, 1cm, 1cm}, clip]{file.pdf}
            \end{figure}

        % Side by Side figures: Use the tabular environment


